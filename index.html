<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Clean</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px 30px;
            max-width: 400px;
            width: 100%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        /* User Header Styles */
        .user-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f1f3f5;
        }

        .user-status {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }

        .user-email {
            font-size: 0.9rem;
            color: #495057;
            font-weight: 500;
        }

        .user-actions {
            display: flex;
            gap: 8px;
        }

        .header-button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .header-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .header-button.secondary {
            background: #6c757d;
        }

        .header-button.secondary:hover {
            background: #5a6268;
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2rem;
            font-weight: 700;
        }

        .task-card {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 30px 20px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }

        .task-text {
            font-size: 1.2rem;
            color: #495057;
            font-weight: 500;
            line-height: 1.4;
        }

        /* Task Progress Styles */
        #taskProgress {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .progress-text {
            font-size: 0.85rem;
            color: #6c757d;
            text-align: center;
            margin: 0;
        }

        /* Task Context Badge Styles */
        #taskContext {
            margin-top: 15px;
        }

        .badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .badge.pillar {
            background: #e3f2fd;
            color: #1976d2;
        }

        .badge.keystone {
            background: #fff3e0;
            color: #f57c00;
        }

        /* Legacy Prompt Styles */
        #legacyPrompt {
            margin-top: 15px;
        }

        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 12px 15px;
            font-size: 0.9rem;
            color: #856404;
            line-height: 1.5;
            margin: 0;
        }

        .info-box strong {
            color: #533f03;
        }

        .info-box a {
            color: #0056b3;
            text-decoration: underline;
            font-weight: 600;
        }

        .info-box a:hover {
            color: #003d82;
        }

        /* Migration Banner Styles (Phase 7) */
        #migrationBanner {
            margin-bottom: 20px;
        }

        .banner {
            position: relative;
            border-radius: 8px;
            padding: 12px 40px 12px 15px;
            font-size: 0.9rem;
            line-height: 1.5;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .banner.info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .banner.info strong {
            color: #062c33;
        }

        .banner.info a {
            color: #0056b3;
            text-decoration: underline;
            font-weight: 600;
        }

        .banner.info a:hover {
            color: #003d82;
        }

        .banner-close {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1.5rem;
            line-height: 1;
            color: #0c5460;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .banner-close:hover {
            color: #062c33;
            transform: translateY(-50%) scale(1.1);
        }

        .streak-counter {
            margin-bottom: 30px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 10px;
            border: 2px solid #28a745;
        }

        .streak-text {
            color: #28a745;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .done-button {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 20px 50px;
            font-size: 1.3rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
            width: 100%;
            max-width: 200px;
        }

        .done-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }

        .done-button:active {
            transform: translateY(0);
        }

        .done-button.completed {
            background: #6c757d;
            cursor: not-allowed;
        }

        .completed-message {
            color: #6c757d;
            font-size: 1.1rem;
            margin-top: 15px;
            display: none;
        }

        .completion-animation {
            animation: pulse 0.6s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @media (max-width: 480px) {
            .container {
                padding: 30px 20px;
            }

            h1 {
                font-size: 1.7rem;
            }

            .task-text {
                font-size: 1.1rem;
            }

            .user-header {
                flex-direction: column;
                gap: 12px;
                align-items: stretch;
            }

            .user-status {
                align-items: center;
            }

            .user-actions {
                justify-content: center;
            }

            .header-button {
                flex: 1;
            }
        }

        /* Authentication Modal Styles */
        #authOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #authModal {
            background: white;
            border-radius: 20px;
            max-width: 420px;
            width: 100%;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.3s ease;
            position: relative;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .auth-form {
            padding: 40px 35px;
        }

        .auth-form h2 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
        }

        .auth-subtitle {
            color: #6c757d;
            font-size: 0.95rem;
            text-align: center;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .form-group label {
            display: block;
            color: #495057;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .form-group input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-group input::placeholder {
            color: #adb5bd;
        }

        .form-hint {
            display: block;
            color: #6c757d;
            font-size: 0.8rem;
            margin-top: 6px;
        }

        .form-help {
            display: block;
            color: #6c757d;
            font-size: 0.75rem;
            margin-top: 4px;
            margin-left: 30px;
            font-style: italic;
        }

        .form-error {
            background: #fff5f5;
            color: #e53e3e;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 20px;
            display: none;
            border: 1px solid #feb2b2;
            white-space: pre-line;
            line-height: 1.5;
        }

        .form-error.show {
            display: block;
        }

        .form-success {
            background: #f0fff4;
            color: #22543d;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 20px;
            border: 1px solid #9ae6b4;
        }

        .warning-text {
            color: #e53e3e;
            font-weight: 600;
        }

        .warning-box {
            background: #fff5f5;
            border: 2px solid #feb2b2;
            border-radius: 8px;
            padding: 16px;
            margin: 20px 0;
        }

        .warning-box strong {
            color: #c53030;
            display: block;
            margin-bottom: 8px;
        }

        .warning-box ul {
            margin: 8px 0 0 20px;
            color: #742a2a;
        }

        .warning-box li {
            margin: 4px 0;
        }

        #changePasswordOverlay,
        #deleteAccountOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .auth-button {
            width: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 16px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .auth-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .auth-button:active:not(:disabled) {
            transform: translateY(0);
        }

        .auth-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .button-loading {
            display: none;
        }

        .auth-button.loading .button-text {
            display: none;
        }

        .auth-button.loading .button-loading {
            display: inline;
        }

        .auth-footer {
            text-align: center;
            margin-top: 25px;
            color: #6c757d;
            font-size: 0.95rem;
        }

        .auth-footer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .auth-footer a:hover {
            text-decoration: underline;
        }

        .close-modal {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            font-size: 2rem;
            color: #adb5bd;
            cursor: pointer;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-modal:hover {
            background: #f8f9fa;
            color: #495057;
        }

        @media (max-width: 480px) {
            .auth-form {
                padding: 35px 25px;
            }

            .auth-form h2 {
                font-size: 1.6rem;
            }

            #authOverlay {
                padding: 15px;
            }
        }

        /* Onboarding Modal Styles */
        #onboardingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        #onboardingModal {
            background: white;
            border-radius: 20px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.3s ease;
            padding: 40px;
        }

        #onboardingModal h2 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
        }

        .onboarding-subtitle {
            color: #6c757d;
            font-size: 0.95rem;
            text-align: center;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #roomConfigSection {
            margin-bottom: 30px;
        }

        #configuredRoomsList h3,
        #addRoomFormSection h3 {
            color: #495057;
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f1f3f5;
        }

        #roomsContainer {
            min-height: 60px;
            margin-bottom: 30px;
        }

        .empty-state {
            color: #adb5bd;
            font-size: 0.9rem;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }

        .room-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .room-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .room-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .room-icon {
            font-size: 1.5rem;
        }

        .room-name {
            font-weight: 600;
            color: #333;
            font-size: 1rem;
            flex: 1;
        }

        .room-type-badge {
            background: #667eea;
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .room-details {
            color: #6c757d;
            font-size: 0.85rem;
            margin-bottom: 10px;
        }

        .glass-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .room-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .edit-room-btn,
        .delete-room-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .edit-room-btn {
            background: #e9ecef;
            color: #495057;
        }

        .edit-room-btn:hover {
            background: #dee2e6;
        }

        .delete-room-btn {
            background: #fff5f5;
            color: #e53e3e;
        }

        .delete-room-btn:hover {
            background: #fed7d7;
        }

        .checkbox-group {
            margin-bottom: 20px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 600;
            color: #495057;
        }

        .checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-label span {
            font-weight: 500;
        }

        select {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.2s ease;
            font-family: inherit;
            background: white;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary.large {
            width: 100%;
            padding: 16px;
            font-size: 1.1rem;
            font-weight: 700;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .modal-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 30px;
        }

        @media (max-width: 640px) {
            #onboardingModal {
                padding: 30px 20px;
                max-height: 95vh;
            }

            #onboardingModal h2 {
                font-size: 1.5rem;
            }

            .room-header {
                flex-wrap: wrap;
            }

            .room-type-badge {
                order: 3;
                width: 100%;
                text-align: center;
                margin-top: 5px;
            }
        }

        /* Offline Status Indicator Styles */
        .offline-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f8d7da;
            color: #721c24;
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #f5c6cb;
            font-size: 0.9rem;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 2000;
            display: none;
            animation: slideInRight 0.3s ease;
        }

        .offline-indicator.show {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .offline-indicator .status-icon {
            font-size: 1.2rem;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Notification Toast Styles */
        .notification-toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            display: none;
            animation: slideInUp 0.3s ease;
            max-width: 350px;
            border-left: 4px solid #667eea;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .notification-toast.show {
            display: block;
        }

        .notification-toast.success {
            border-left-color: #28a745;
        }

        .notification-toast.info {
            border-left-color: #17a2b8;
        }

        .notification-toast.warning {
            border-left-color: #ffc107;
        }

        .notification-toast.error {
            border-left-color: #dc3545;
        }

        .notification-toast .toast-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .notification-toast .toast-icon {
            font-size: 1.5rem;
        }

        .notification-toast .toast-message {
            color: #333;
            font-size: 0.95rem;
            font-weight: 500;
        }


        /* Sync Queue Indicator */
        .sync-queue-indicator {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: #fff3cd;
            color: #856404;
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #ffeaa7;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 1500;
            display: none;
            animation: pulse 2s infinite;
        }

        .sync-queue-indicator.show {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @media (max-width: 480px) {
            .offline-indicator,
            .notification-toast,
            .sync-queue-indicator {
                left: 15px;
                right: 15px;
                max-width: calc(100% - 30px);
            }
        }

        /* Settings Modal Styles */
        #settingsOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        #settingsModal {
            background: white;
            border-radius: 20px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.3s ease;
            padding: 0;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 40px 20px;
            border-bottom: 2px solid #f1f3f5;
        }

        .modal-header h2 {
            color: #333;
            font-size: 1.8rem;
            font-weight: 700;
            margin: 0;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 2rem;
            color: #adb5bd;
            cursor: pointer;
            transition: color 0.2s ease;
            line-height: 1;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-modal-btn:hover {
            color: #495057;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #e9ecef;
            padding: 0 40px;
            background: #f8f9fa;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 15px 20px;
            font-size: 0.95rem;
            font-weight: 600;
            color: #6c757d;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .tab-btn:hover {
            color: #495057;
            background: #fff;
        }

        .tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #fff;
        }

        .tab-content {
            padding: 30px 40px;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        .tab-pane h3 {
            color: #333;
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .tab-description {
            color: #6c757d;
            font-size: 0.9rem;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        /* Settings Room List */
        #settingsRoomsList {
            margin-bottom: 20px;
            min-height: 80px;
        }

        .settings-room-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .settings-room-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .settings-room-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .room-reorder-controls {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .reorder-btn {
            background: #e9ecef;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 20px;
            cursor: pointer;
            font-size: 0.7rem;
            color: #495057;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reorder-btn:hover:not(:disabled) {
            background: #dee2e6;
            color: #212529;
        }

        .reorder-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Keystone Items */
        .keystone-item {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .keystone-toggle {
            flex-shrink: 0;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        .keystone-info {
            flex: 1;
        }

        .keystone-default-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .keystone-custom-name {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .keystone-custom-name:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .keystone-custom-name::placeholder {
            color: #adb5bd;
            font-style: italic;
        }

        /* Keystone Onboarding */
        #keystoneOnboardingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
        }

        #keystoneOnboardingModal {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .keystone-checklist {
            margin: 25px 0;
        }

        .keystone-onboarding-item {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            display: flex;
            align-items: flex-start;
            gap: 15px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .keystone-onboarding-item:hover {
            border-color: #667eea;
            background: #f5f7ff;
        }

        .keystone-onboarding-item.selected {
            border-color: #667eea;
            background: #f5f7ff;
        }

        .keystone-checkbox-container {
            flex-shrink: 0;
            padding-top: 2px;
        }

        .keystone-checkbox {
            width: 24px;
            height: 24px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .keystone-content {
            flex: 1;
        }

        .keystone-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            font-size: 1rem;
        }

        .keystone-description {
            color: #6c757d;
            font-size: 0.875rem;
            line-height: 1.4;
        }

        .no-keystones-message {
            text-align: center;
            padding: 40px 20px;
            color: #6c757d;
        }

        .no-keystones-message p {
            margin: 10px 0;
            font-size: 1rem;
        }

        .onboarding-footer {
            margin: 20px 0 10px;
            padding: 15px;
            background: #e7f3ff;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .help-text {
            margin: 0;
            color: #495057;
            font-size: 0.9rem;
        }

        /* Task Preview */
        .preview-task-item {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            transition: all 0.2s ease;
        }

        .preview-task-item.current {
            background: #e7f3ff;
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
        }

        .task-number {
            background: #667eea;
            color: white;
            font-weight: 700;
            font-size: 0.85rem;
            padding: 6px 12px;
            border-radius: 8px;
            min-width: 35px;
            text-align: center;
        }

        .preview-task-item.current .task-number {
            background: linear-gradient(45deg, #667eea, #764ba2);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .task-description {
            flex: 1;
            color: #333;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .task-meta {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge.pillar {
            background: #e7f3ff;
            color: #0066cc;
        }

        .badge.keystone {
            background: #fff5e6;
            color: #cc7a00;
        }

        .preview-legend {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .legend-items {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .legend-text {
            color: #6c757d;
            font-size: 0.85rem;
        }

        .progress-text {
            color: #495057;
            font-size: 0.95rem;
            font-weight: 500;
        }

        /* Account Info */
        .account-info {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #6c757d;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .info-value {
            color: #333;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .account-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Notice Styles */
        .notice-warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .notice-warning p {
            color: #856404;
            font-size: 0.9rem;
            margin: 0;
            font-weight: 500;
        }

        /* Modal Actions */
        .modal-actions {
            padding: 20px 40px 30px;
            border-top: 2px solid #f1f3f5;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn-danger {
            background: #e53e3e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-danger:hover {
            background: #c53030;
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.3);
        }

        /* Responsive adjustments for Settings Modal */
        @media (max-width: 768px) {
            #settingsModal {
                max-width: 100%;
                border-radius: 0;
            }

            .modal-header,
            .tab-content,
            .tabs {
                padding-left: 20px;
                padding-right: 20px;
            }

            .modal-actions {
                padding-left: 20px;
                padding-right: 20px;
            }

            .tabs {
                overflow-x: auto;
                white-space: nowrap;
            }

            .tab-btn {
                padding: 12px 15px;
                font-size: 0.85rem;
            }

            .legend-items {
                flex-direction: column;
                gap: 10px;
            }
        }
        /* Email Verification Banner Styles */
        .verification-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 12px 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1001;
            animation: slideDown 0.3s ease;
            display: none;
        }

        .verification-banner.show {
            display: block;
        }

        .verification-banner-content {
            max-width: 600px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .verification-banner-icon {
            font-size: 1.2rem;
        }

        .verification-banner-text {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .verification-banner-btn {
            background: white;
            color: #d97706;
            border: none;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .verification-banner-btn:hover {
            background: #fef3c7;
            transform: translateY(-1px);
        }

        .verification-banner-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0 8px;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        .verification-banner-close:hover {
            opacity: 1;
        }

        /* Email Verification Modal Styles */
        #emailVerificationOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1002;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }

        #emailVerificationOverlay.show {
            display: flex;
        }

        #emailVerificationModal {
            background: white;
            border-radius: 20px;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.3s ease;
            padding: 40px 35px;
            text-align: center;
            position: relative;
        }

        .verification-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .verification-icon.success {
            color: #10b981;
        }

        .verification-icon.error {
            color: #ef4444;
        }

        .verification-icon.loading {
            color: #667eea;
        }

        .verification-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
        }

        .verification-message {
            font-size: 1rem;
            color: #6c757d;
            line-height: 1.6;
            margin-bottom: 25px;
        }

        .verification-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .verification-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .verification-btn.primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .verification-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .verification-btn.secondary {
            background: #e9ecef;
            color: #495057;
        }

        .verification-btn.secondary:hover {
            background: #dee2e6;
        }

        .verification-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Adjust container when banner is visible */
        body.banner-visible .container {
            margin-top: 60px;
        }

        @media (max-width: 480px) {
            .verification-banner {
                padding: 10px 15px;
            }

            .verification-banner-content {
                gap: 8px;
            }

            .verification-banner-text {
                font-size: 0.85rem;
            }

            #emailVerificationModal {
                padding: 30px 25px;
            }

            .verification-title {
                font-size: 1.5rem;
            }

            .verification-message {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <!-- Offline Status Indicator -->
    <div class="offline-indicator" id="offlineIndicator">
        <span class="status-icon">&#9888;</span>
        <span>You're offline. Changes will sync when reconnected.</span>
    </div>

    <!-- Notification Toast -->
    <div class="notification-toast" id="notificationToast">
        <div class="toast-content">
            <span class="toast-icon" id="toastIcon"></span>
            <span class="toast-message" id="toastMessage"></span>
        </div>
    </div>

    <!-- Sync Queue Indicator -->
    <div class="sync-queue-indicator" id="syncQueueIndicator">
        <span>&#8987;</span>
        <span id="syncQueueText">Pending sync...</span>
    </div>

    <div class="container">
        <!-- User Header -->
        <div class="user-header">
            <div class="user-status" id="userStatus">
                <span class="user-email" id="userEmail" style="display: none;"></span>
            </div>
            <div class="user-actions">
                <button class="header-button" id="settingsButton" style="display: none;">Settings</button>
                <button class="header-button" id="loginButton">Sign In</button>
                <button class="header-button secondary" id="logoutButton" style="display: none;">Sign Out</button>
            </div>
        </div>

        <!-- Migration Banner (Phase 7: for existing users without room configuration) -->
        <div id="migrationBanner" style="display: none;">
            <div class="banner info">
                <p>
                    <strong>âœ¨ New Feature!</strong>
                    Get personalized cleaning tasks based on your home setup.
                    <a href="#" onclick="openSettingsModal(); return false;">
                        Configure your rooms now
                    </a>
                </p>
                <button class="banner-close" onclick="dismissMigrationBanner()">Ã—</button>
            </div>
        </div>

        <h1>Daily Clean</h1>

        <div class="task-card">
            <!-- Progress indicator (only for configured users) -->
            <div id="taskProgress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 0%"></div>
                </div>
                <p class="progress-text">
                    Task <strong id="currentPosition">1</strong> of
                    <strong id="totalTasks">28</strong>
                </p>
            </div>

            <!-- Task description -->
            <div class="task-text" id="taskText"></div>

            <!-- Context badge (only for rotation tasks) -->
            <div id="taskContext" style="display: none;">
                <span id="taskBadge" class="badge"></span>
            </div>

            <!-- Legacy user prompt -->
            <div id="legacyPrompt" style="display: none;">
                <p class="info-box">
                    ðŸ’¡ <strong>Personalize your tasks!</strong>
                    <a href="#" onclick="openSettingsModal(); return false;">Configure your home</a> to get room-specific tasks.
                </p>
            </div>
        </div>

        <div class="streak-counter">
            <div class="streak-text" id="streakText"></div>
        </div>

        <button class="done-button" id="doneButton">
            Done!
        </button>

        <div class="completed-message" id="completedMessage">
            Already completed today! Come back tomorrow for your next task.
        </div>
    </div>

    <!-- Authentication Modal Overlay -->
    <div id="authOverlay" style="display: none;">
        <div id="authModal">
            <!-- Login Form -->
            <div id="loginForm" class="auth-form">
                <h2>Welcome Back!</h2>
                <p class="auth-subtitle">Sign in to sync your streak across devices</p>

                <form id="loginFormElement">
                    <div class="form-group">
                        <label for="loginEmail">Email</label>
                        <input type="email" id="loginEmail" name="email" required autocomplete="email" placeholder="you@example.com">
                    </div>

                    <div class="form-group">
                        <label for="loginPassword">Password</label>
                        <input type="password" id="loginPassword" name="password" required autocomplete="current-password" placeholder="Enter your password">
                    </div>

                    <div class="form-error" id="loginError"></div>

                    <button type="submit" class="auth-button" id="loginSubmitButton">
                        <span class="button-text">Sign In</span>
                        <span class="button-loading" style="display: none;">Signing in...</span>
                    </button>
                </form>

                <div class="auth-footer">
                    <p>Don't have an account? <a href="#" id="showRegisterLink">Create one</a></p>
                </div>

                <button class="close-modal" id="closeLoginModal" aria-label="Close">&times;</button>
            </div>

            <!-- Register Form -->
            <div id="registerForm" class="auth-form" style="display: none;">
                <h2>Create Account</h2>
                <p class="auth-subtitle">Start syncing your cleaning streak today</p>

                <form id="registerFormElement">
                    <div class="form-group">
                        <label for="registerEmail">Email</label>
                        <input type="email" id="registerEmail" name="email" required autocomplete="email" placeholder="you@example.com">
                    </div>

                    <div class="form-group">
                        <label for="registerPassword">Password</label>
                        <input type="password" id="registerPassword" name="password" required autocomplete="new-password" placeholder="At least 8 characters">
                        <small class="form-hint">Use 8+ characters with letters, numbers, and symbols</small>
                    </div>

                    <div class="form-group">
                        <label for="registerConfirmPassword">Confirm Password</label>
                        <input type="password" id="registerConfirmPassword" name="confirmPassword" required autocomplete="new-password" placeholder="Confirm your password">
                    </div>

                    <div class="form-error" id="registerError"></div>

                    <button type="submit" class="auth-button" id="registerSubmitButton">
                        <span class="button-text">Create Account</span>
                        <span class="button-loading" style="display: none;">Creating account...</span>
                    </button>
                </form>

                <div class="auth-footer">
                    <p>Already have an account? <a href="#" id="showLoginLink">Sign in</a></p>
                </div>

                <button class="close-modal" id="closeRegisterModal" aria-label="Close">&times;</button>
            </div>
        </div>
    </div>

    <!-- Onboarding Modal Overlay -->
    <div id="onboardingOverlay" style="display: none;">
        <div id="onboardingModal">
            <h2>Welcome! Let's Set Up Your Home</h2>
            <p class="onboarding-subtitle">Configure your rooms to get personalized cleaning tasks based on the three-pillars methodology.</p>

            <div id="roomConfigSection">
                <!-- Add room form -->
                <div id="addRoomFormSection">
                    <h3>Add a Room</h3>
                    <form id="roomForm">
                        <div class="form-group">
                            <label for="roomType">Room Type</label>
                            <select id="roomType" required>
                                <option value="">Select room type...</option>
                                <option value="living_room">Living Room</option>
                                <option value="bedroom">Bedroom</option>
                                <option value="kitchen">Kitchen</option>
                                <option value="bathroom">Bathroom</option>
                                <option value="office">Office</option>
                                <option value="dining_room">Dining Room</option>
                                <option value="laundry">Laundry Room</option>
                                <option value="garage">Garage</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="customRoomName">Custom Name (Optional)</label>
                            <input type="text" id="customRoomName"
                                   placeholder="Leave empty to use default name (e.g., Living Room)"
                                   maxlength="50">
                            <small class="form-hint">Optional: Add a specific name only if you have multiple rooms of the same type (e.g., "Master Bedroom", "Guest Bathroom")</small>
                        </div>

                        <div class="form-group checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="hasGlass" checked>
                                <span>This room has mirrors or windows</span>
                            </label>
                            <small class="form-hint">Uncheck if this room has no glass surfaces to clean</small>
                        </div>

                        <button type="submit" class="btn-primary">Add Room</button>
                    </form>
                </div>

                <!-- Configured rooms display -->
                <div id="configuredRoomsList">
                    <h3>Your Rooms</h3>
                    <div id="roomsContainer">
                        <p class="empty-state">No rooms added yet. Start by adding your first room above!</p>
                    </div>
                </div>
            </div>

            <!-- Action buttons -->
            <div class="modal-actions">
                <button id="finishOnboarding" class="btn-primary large" disabled>
                    Generate My Tasks
                </button>
                <button id="skipOnboarding" class="btn-secondary">Skip for Now</button>
            </div>
        </div>
    </div>

    <!-- Keystone Onboarding Modal Overlay -->
    <div id="keystoneOnboardingOverlay" style="display: none;">
        <div id="keystoneOnboardingModal">
            <h2>ðŸ”‘ Configure High-Frequency Hygiene Points</h2>
            <p class="onboarding-subtitle">
                Select the high-traffic areas in your home that need frequent attention.
                These tasks will be interspersed throughout your cleaning rotation.
            </p>

            <div id="keystoneOnboardingList" class="keystone-checklist">
                <!-- Keystones will be rendered here -->
            </div>

            <div class="onboarding-footer">
                <p class="help-text">
                    ðŸ’¡ <strong>Tip:</strong> You can always customize these later in Settings.
                </p>
            </div>

            <!-- Action buttons -->
            <div class="modal-actions">
                <button id="saveKeystonesOnboarding" class="btn-primary large">
                    Save & Start Cleaning!
                </button>
                <button id="skipKeystonesOnboarding" class="btn-secondary">Skip for Now</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal Overlay -->
    <div id="settingsOverlay" style="display: none;">
        <div id="settingsModal">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="close-modal-btn" id="closeSettingsModal" aria-label="Close">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab-btn active" data-tab="rooms">My Rooms</button>
                <button class="tab-btn" data-tab="keystones">Keystone Tasks</button>
                <button class="tab-btn" data-tab="preview">Task Preview</button>
                <button class="tab-btn" data-tab="account">Account</button>
            </div>

            <!-- Tab Contents -->
            <div class="tab-content">
                <!-- My Rooms Tab -->
                <div id="roomsTab" class="tab-pane active">
                    <!-- Add Room Form (hidden initially) -->
                    <div id="addRoomInSettings" style="display: none;">
                        <h3>Add a New Room</h3>
                        <form id="roomFormSettings">
                            <div class="form-group">
                                <label for="roomTypeSettings">Room Type</label>
                                <select id="roomTypeSettings" required>
                                    <option value="">Select room type...</option>
                                    <option value="living_room">Living Room</option>
                                    <option value="bedroom">Bedroom</option>
                                    <option value="kitchen">Kitchen</option>
                                    <option value="bathroom">Bathroom</option>
                                    <option value="office">Office</option>
                                    <option value="dining_room">Dining Room</option>
                                    <option value="laundry">Laundry Room</option>
                                    <option value="garage">Garage</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="customRoomNameSettings">Custom Name (Optional)</label>
                                <input type="text" id="customRoomNameSettings"
                                       placeholder="Leave empty to use default name (e.g., Living Room)"
                                       maxlength="50">
                                <small class="form-hint">Optional: Add a specific name only if you have multiple rooms of the same type</small>
                            </div>

                            <div class="form-group checkbox-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="hasGlassSettings" checked>
                                    <span>This room has mirrors or windows</span>
                                </label>
                            </div>

                            <div class="form-group checkbox-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="autoAddKeystonesSettings" checked>
                                    <span>Automatically add keystone tasks for this room</span>
                                </label>
                                <small class="form-help">High-frequency hygiene points like sinks, toilets, and stovetops</small>
                            </div>

                            <div class="form-actions">
                                <button type="submit" class="btn-primary">Add Room</button>
                                <button type="button" class="btn-secondary" id="cancelAddRoomSettings">Cancel</button>
                            </div>
                        </form>
                    </div>

                    <button id="addRoomSettingsBtn" class="btn-primary">
                        + Add Room
                    </button>

                    <div id="settingsRoomsList">
                        <!-- Room cards will be rendered here -->
                    </div>

                    <!-- Pending changes notice -->
                    <div id="pendingChangesNotice" class="notice-warning" style="display: none;">
                        <p>Your changes will be applied after you complete the current rotation cycle.</p>
                    </div>
                </div>

                <!-- Keystone Tasks Tab -->
                <div id="keystonesTab" class="tab-pane">
                    <h3>High-Frequency Hygiene Points</h3>
                    <p class="tab-description">Enable/disable keystone tasks and customize their names. These tasks are interspersed throughout your rotation.</p>

                    <div id="keystonesList">
                        <!-- Keystone items will be rendered here -->
                    </div>
                </div>

                <!-- Task Preview Tab -->
                <div id="previewTab" class="tab-pane">
                    <h3>Your Task Rotation</h3>
                    <p class="tab-description">Preview your upcoming tasks in the rotation.</p>

                    <div id="taskPreviewList">
                        <div class="loading-spinner">
                            <div class="spinner"></div>
                            <p>Loading task preview...</p>
                        </div>
                    </div>

                    <div class="preview-legend">
                        <div class="legend-items">
                            <span class="legend-item">
                                <span class="badge pillar">Pillar Task</span>
                                <span class="legend-text">Room-based cleaning task</span>
                            </span>
                            <span class="legend-item">
                                <span class="badge keystone">Keystone</span>
                                <span class="legend-text">High-frequency hygiene point</span>
                            </span>
                        </div>
                        <p class="progress-text">Current position: <strong id="currentPositionPreview">-</strong> / <strong id="totalTasksPreview">-</strong></p>
                    </div>
                </div>

                <!-- Account Tab -->
                <div id="accountTab" class="tab-pane">
                    <h3>Account Settings</h3>
                    <div class="account-info">
                        <div class="info-row">
                            <span class="info-label">Email:</span>
                            <span class="info-value" id="accountEmail">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Account Created:</span>
                            <span class="info-value" id="accountCreated">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Total Completions:</span>
                            <span class="info-value" id="accountCompletions">-</span>
                        </div>
                    </div>

                    <div class="account-actions">
                        <button class="btn-secondary" id="changePasswordBtn">Change Password</button>
                        <button class="btn-danger" id="deleteAccountBtn">Delete Account</button>
                    </div>
                </div>
            </div>

            <!-- Modal Actions -->
            <div class="modal-actions">
                <button id="saveSettingsBtn" class="btn-primary">Save Changes</button>
                <button class="btn-secondary" id="cancelSettingsBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Change Password Modal Overlay -->
    <div id="changePasswordOverlay" style="display: none;">
        <div id="changePasswordModal" class="auth-form">
            <h2>Change Password</h2>
            <p class="auth-subtitle">Enter your current password and choose a new one</p>

            <form id="changePasswordForm">
                <div class="form-group">
                    <label for="currentPassword">Current Password</label>
                    <input type="password" id="currentPassword" name="currentPassword" required autocomplete="current-password" placeholder="Enter current password">
                </div>

                <div class="form-group">
                    <label for="newPassword">New Password</label>
                    <input type="password" id="newPassword" name="newPassword" required autocomplete="new-password" placeholder="At least 8 characters">
                    <small class="form-hint">Use 8+ characters with uppercase, lowercase, numbers, and symbols</small>
                </div>

                <div class="form-group">
                    <label for="confirmNewPassword">Confirm New Password</label>
                    <input type="password" id="confirmNewPassword" name="confirmNewPassword" required autocomplete="new-password" placeholder="Confirm new password">
                </div>

                <div class="form-error" id="changePasswordError"></div>
                <div class="form-success" id="changePasswordSuccess" style="display: none;"></div>

                <div class="form-actions">
                    <button type="submit" class="auth-button" id="changePasswordSubmitBtn">
                        <span class="button-text">Change Password</span>
                        <span class="button-loading" style="display: none;">Changing password...</span>
                    </button>
                    <button type="button" class="btn-secondary" id="cancelChangePasswordBtn">Cancel</button>
                </div>
            </form>

            <button class="close-modal" id="closeChangePasswordModal" aria-label="Close">&times;</button>
        </div>
    </div>

    <!-- Delete Account Modal Overlay -->
    <div id="deleteAccountOverlay" style="display: none;">
        <div id="deleteAccountModal" class="auth-form">
            <h2>Delete Account</h2>
            <p class="auth-subtitle warning-text">This action is permanent and cannot be undone!</p>

            <div class="warning-box">
                <strong>Warning:</strong> Deleting your account will permanently remove:
                <ul>
                    <li>All your task completions</li>
                    <li>Your streak history</li>
                    <li>Your room configurations</li>
                    <li>All account data</li>
                </ul>
            </div>

            <form id="deleteAccountForm">
                <div class="form-group">
                    <label for="deleteAccountEmail">Confirm your email</label>
                    <input type="email" id="deleteAccountEmail" name="email" required autocomplete="email" placeholder="Enter your email">
                </div>

                <div class="form-group">
                    <label for="deleteAccountConfirmation">Type "DELETE MY ACCOUNT" to confirm</label>
                    <input type="text" id="deleteAccountConfirmation" name="confirmation" required placeholder="DELETE MY ACCOUNT">
                </div>

                <div class="form-error" id="deleteAccountError"></div>

                <div class="form-actions">
                    <button type="submit" class="btn-danger" id="deleteAccountSubmitBtn">
                        <span class="button-text">Delete Account</span>
                        <span class="button-loading" style="display: none;">Deleting account...</span>
                    </button>
                    <button type="button" class="btn-secondary" id="cancelDeleteAccountBtn">Cancel</button>
                </div>
            </form>

            <button class="close-modal" id="closeDeleteAccountModal" aria-label="Close">&times;</button>
        </div>
    </div>

    <!-- Email Verification Banner -->
    <div id="verificationBanner" class="verification-banner">
        <div class="verification-banner-content">
            <span class="verification-banner-icon">âœ‰ï¸</span>
            <span class="verification-banner-text">Please verify your email address to secure your account.</span>
            <button class="verification-banner-btn" id="resendVerificationBtn">Resend Email</button>
            <button class="verification-banner-close" id="closeVerificationBanner" aria-label="Close">&times;</button>
        </div>
    </div>

    <!-- Email Verification Modal -->
    <div id="emailVerificationOverlay">
        <div id="emailVerificationModal">
            <div id="verificationContent">
                <!-- Content will be dynamically updated -->
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CONSTANTS AND CONFIGURATION
        // ============================================
        const API_BASE_URL = 'https://api.stenotes.com/api';
        const API_TIMEOUT = 10000; // 10 seconds

        const cleaningTasks = [
            "Make your bed",
            "Wipe down kitchen counters",
            "Clean bathroom mirror",
            "Dust living room TV",
            "Organize one drawer",
            "Vacuum entryway",
            "Wipe down light switches",
            "Clean coffee table",
            "Tidy up couch cushions",
            "Wipe down door handles",
            "Clean kitchen sink",
            "Organize desk workspace",
            "Dust nightstand",
            "Wipe bathroom counter",
            "Sweep kitchen floor",
            "Clean toilet seat and rim",
            "Organize medicine cabinet",
            "Dust picture frames",
            "Wipe down refrigerator exterior",
            "Clean computer keyboard",
            "Organize bookshelf",
            "Dust ceiling fan blades",
            "Wipe down dining table",
            "Clean microwave interior",
            "Organize closet floor",
            "Dust windowsills",
            "Clean shower door or curtain",
            "Wipe down baseboards in one room",
            "Organize pantry shelf",
            "Clean bathroom faucet",
            "Dust lamp shades",
            "Wipe down kitchen appliances",
            "Organize junk drawer",
            "Clean mirror in bedroom",
            "Vacuum stairs",
            "Wipe down trash cans",
            "Organize shoes by front door",
            "Clean inside of dishwasher",
            "Dust electronics",
            "Wipe down cabinet fronts",
            "Organize bathroom drawer",
            "Clean stovetop",
            "Dust coffee table books",
            "Wipe down washing machine",
            "Organize coat closet",
            "Clean bathroom scale",
            "Dust dining chairs",
            "Wipe down phone and chargers",
            "Organize one kitchen cabinet",
            "Clean out car cup holders"
        ];

        // ============================================
        // API COMMUNICATION LAYER (Step 25)
        // ============================================

        /**
         * Make an authenticated API request with error handling
         * @param {string} endpoint - API endpoint path (e.g., '/auth/register')
         * @param {object} options - Fetch options (method, body, etc.)
         * @returns {Promise<object>} Response data
         */
        async function apiRequest(endpoint, options = {}, isRetry = false) {
            const url = `${API_BASE_URL}${endpoint}`;

            const defaultOptions = {
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'include', // Include cookies for JWT
                ...options
            };

            // Merge headers properly
            if (options.headers) {
                defaultOptions.headers = {
                    ...defaultOptions.headers,
                    ...options.headers
                };
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT);

                const response = await fetch(url, {
                    ...defaultOptions,
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                // Parse response
                let data;
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    data = await response.json();
                } else {
                    data = { message: await response.text() };
                }

                // Handle non-OK responses
                if (!response.ok) {
                    // Handle 401 Unauthorized - attempt token refresh
                    if (response.status === 401 && !isRetry && AppState.user.isAuthenticated) {
                        console.log('Received 401 error - attempting token refresh');

                        const refreshSuccess = await refreshAccessToken();

                        if (refreshSuccess) {
                            // Retry the original request with refreshed token
                            console.log('Token refreshed - retrying original request');
                            return apiRequest(endpoint, options, true); // Pass isRetry=true to prevent infinite loop
                        } else {
                            // Refresh failed - session expired
                            await handleSessionExpired();
                            throw new Error('Session expired. Please log in again.');
                        }
                    }

                    // Extract error message from various response formats
                    let errorMessage = data.message || data.error || `HTTP ${response.status}`;

                    // If there are validation details, format them into a readable message
                    if (data.details && Array.isArray(data.details) && data.details.length > 0) {
                        // Join all validation errors with line breaks
                        errorMessage = data.details.join('\n');
                    }

                    const error = new Error(errorMessage);
                    error.status = response.status;
                    error.data = data;
                    throw error;
                }

                return data;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error('Request timeout - please check your connection');
                }

                // Network errors
                if (error instanceof TypeError) {
                    throw new Error('Network error - please check your connection');
                }

                // Re-throw API errors with message
                throw error;
            }
        }

        /**
         * Refresh the access token using the refresh token
         * @returns {Promise<boolean>} True if refresh succeeds, false otherwise
         */
        async function refreshAccessToken() {
            try {
                console.log('Attempting to refresh access token...');

                // Call refresh endpoint - new tokens set automatically via cookies
                const response = await fetch(`${API_BASE_URL}/auth/refresh`, {
                    method: 'POST',
                    credentials: 'include', // Include refresh token cookie
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    console.log('Access token refreshed successfully');
                    return true;
                }

                console.warn('Token refresh failed:', response.status);
                return false;
            } catch (error) {
                console.error('Token refresh error:', error);
                return false;
            }
        }

        /**
         * Handle session expiration - log user out gracefully
         */
        async function handleSessionExpired() {
            console.log('Session expired - logging out user');

            // Clear authentication state
            AppState.user.isAuthenticated = false;
            AppState.user.profile = null;
            AppState.user.email = null;

            // Clear persisted state
            clearState();

            // Update UI
            updateAuthUI();

            // Show notification
            showNotification('Your session has expired. Please log in again.', 'info', 5000);

            // Show login modal
            showAuthModal('login');
        }

        /**
         * Authentication API Methods
         */
        const AuthAPI = {
            /**
             * Register a new user
             * @param {string} email - User email
             * @param {string} password - User password
             * @param {string} confirmPassword - Password confirmation
             * @returns {Promise<object>} User data and session info
             */
            async register(email, password, confirmPassword) {
                return apiRequest('/auth/register', {
                    method: 'POST',
                    body: JSON.stringify({ email, password, confirmPassword })
                });
            },

            /**
             * Login existing user
             * @param {string} email - User email
             * @param {string} password - User password
             * @returns {Promise<object>} User data and session info
             */
            async login(email, password) {
                return apiRequest('/auth/login', {
                    method: 'POST',
                    body: JSON.stringify({ email, password })
                });
            },

            /**
             * Logout current user
             * @returns {Promise<object>} Logout confirmation
             */
            async logout() {
                return apiRequest('/auth/logout', {
                    method: 'POST'
                });
            },

            /**
             * Get current user session
             * @returns {Promise<object>} Current user data
             */
            async getSession() {
                return apiRequest('/auth/session', {
                    method: 'GET'
                });
            },

            /**
             * Verify email address with token
             * @param {string} token - Verification token from email
             * @returns {Promise<object>} Verification result
             */
            async verifyEmail(token) {
                return apiRequest(`/auth/verify-email?token=${encodeURIComponent(token)}`, {
                    method: 'GET'
                });
            },

            /**
             * Resend verification email
             * @param {string} email - User email address
             * @returns {Promise<object>} Resend confirmation
             */
            async resendVerification(email) {
                return apiRequest('/auth/resend-verification', {
                    method: 'POST',
                    body: JSON.stringify({ email })
                });
            }
        };

        /**
         * User Data API Methods
         */
        const UserAPI = {
            /**
             * Get user profile
             * @returns {Promise<object>} User profile data
             */
            async getProfile() {
                return apiRequest('/user/profile', {
                    method: 'GET'
                });
            },

            /**
             * Get all user streaks
             * @returns {Promise<object>} All streak statistics
             */
            async getStreaks() {
                return apiRequest('/user/streaks', {
                    method: 'GET'
                });
            },

            /**
             * Complete today's task
             * @param {string} taskDescription - Task that was completed
             * @param {string|null} taskRotationId - Task rotation ID (null for legacy tasks)
             * @returns {Promise<object>} Updated streak data
             */
            async completeTask(taskDescription, taskRotationId = null) {
                return apiRequest('/user/complete', {
                    method: 'POST',
                    body: JSON.stringify({
                        taskName: taskDescription,
                        task_rotation_id: taskRotationId
                    })
                });
            },

            /**
             * Get completion history
             * @param {number} limit - Number of records to retrieve
             * @param {number} offset - Pagination offset
             * @returns {Promise<object>} History records
             */
            async getHistory(limit = 30, offset = 0) {
                return apiRequest(`/user/history?limit=${limit}&offset=${offset}`, {
                    method: 'GET'
                });
            },

            /**
             * Get analytics data
             * @returns {Promise<object>} User analytics
             */
            async getAnalytics() {
                return apiRequest('/user/analytics', {
                    method: 'GET'
                });
            },

            /**
             * Update user preferences
             * @param {object} preferences - User preferences object
             * @returns {Promise<object>} Updated preferences
             */
            async updatePreferences(preferences) {
                return apiRequest('/user/preferences', {
                    method: 'PUT',
                    body: JSON.stringify({ preferences })
                });
            }
        };

        /**
         * Room Configuration API Methods
         */
        const RoomAPI = {
            /**
             * Create a new room
             * @param {object} roomData - Room configuration { roomType, customName, hasGlass }
             * @returns {Promise<object>} Created room object
             */
            async createRoom(roomData) {
                return apiRequest('/rooms', {
                    method: 'POST',
                    body: JSON.stringify(roomData)
                });
            },

            /**
             * Get all user rooms
             * @returns {Promise<object>} Array of room configurations
             */
            async getUserRooms() {
                return apiRequest('/rooms', {
                    method: 'GET'
                });
            },

            /**
             * Get room by ID
             * @param {string} roomId - Room ID
             * @returns {Promise<object>} Room object
             */
            async getRoomById(roomId) {
                return apiRequest(`/rooms/${roomId}`, {
                    method: 'GET'
                });
            },

            /**
             * Update room configuration
             * @param {string} roomId - Room ID
             * @param {object} updates - Room updates { customName?, hasGlass? }
             * @returns {Promise<object>} Updated room object
             */
            async updateRoom(roomId, updates) {
                return apiRequest(`/rooms/${roomId}`, {
                    method: 'PUT',
                    body: JSON.stringify(updates)
                });
            },

            /**
             * Delete a room
             * @param {string} roomId - Room ID
             * @returns {Promise<object>} Success confirmation
             */
            async deleteRoom(roomId) {
                return apiRequest(`/rooms/${roomId}`, {
                    method: 'DELETE'
                });
            },

            /**
             * Reorder rooms
             * @param {Array<string>} roomIds - Array of room IDs in desired order
             * @returns {Promise<object>} Success confirmation
             */
            async reorderRooms(roomIds) {
                return apiRequest('/rooms/reorder', {
                    method: 'PUT',
                    body: JSON.stringify({ room_order: roomIds })
                });
            }
        };

        /**
         * Task Rotation API Methods
         */
        const TaskAPI = {
            /**
             * Get current task from rotation
             * @returns {Promise<object>} Current task object
             */
            async getCurrentTask() {
                return apiRequest('/tasks/current', {
                    method: 'GET'
                });
            },

            /**
             * Preview upcoming tasks
             * @param {number} limit - Number of tasks to preview
             * @returns {Promise<object>} Array of upcoming tasks
             */
            async previewTasks(limit = 20) {
                return apiRequest(`/tasks/preview?limit=${limit}`, {
                    method: 'GET'
                });
            },

            /**
             * Regenerate task rotation
             * @returns {Promise<object>} New rotation info
             */
            async regenerateRotation() {
                return apiRequest('/tasks/regenerate', {
                    method: 'POST'
                });
            }
        };

        /**
         * Keystone Task Configuration API Methods
         */
        const KeystoneAPI = {
            /**
             * Get user's keystone tasks
             * @param {boolean} activeOnly - Return only active keystones
             * @returns {Promise<object>} Keystone tasks data
             */
            async getUserKeystones(activeOnly = false) {
                const query = activeOnly ? '?active_only=true' : '';
                return apiRequest(`/keystone-tasks${query}`, {
                    method: 'GET'
                });
            },

            /**
             * Initialize keystone tasks for a new user
             * @param {Array} keystones - Array of keystone objects with task_type and custom_name
             * @returns {Promise<object>} Created keystones data
             */
            async initializeKeystones(keystones = []) {
                return apiRequest('/keystone-tasks/initialize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ keystones })
                });
            },

            /**
             * Add keystones for a specific room
             * @param {Array} keystones - Array of keystone objects with task_type and custom_name
             * @returns {Promise<object>} Created keystones data
             */
            async addKeystonesForRoom(keystones) {
                return apiRequest('/keystone-tasks/add-for-room', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ keystones })
                });
            },

            /**
             * Update a keystone task
             * @param {string} keystoneId - Keystone task ID
             * @param {object} updates - Update data
             * @returns {Promise<object>} Updated keystone data
             */
            async updateKeystone(keystoneId, updates) {
                return apiRequest(`/keystone-tasks/${keystoneId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updates)
                });
            }
        };

        // ============================================
        // STATE MANAGEMENT SYSTEM (Step 26)
        // ============================================

        /**
         * Application State Object
         * Supports both anonymous (localStorage) and authenticated (API + cache) modes
         */
        const AppState = {
            // Core streak data
            streak: {
                current: 0,
                lastCompletedDate: null, // ISO string
                bestStreak: 0,
                history: [] // Array of completion date objects
            },

            // Current task (legacy format)
            task: {
                text: "",
                date: null,
                completed: false
            },

            // Current task (rotation-based format)
            currentTask: null, // { id, description, taskType, room, pillarType, keystoneType, position, totalTasks, isLegacy }

            // User authentication state
            user: {
                isAuthenticated: false,
                profile: null, // { id, email, createdAt, preferences }
                hasConfiguredRooms: false // Whether user has set up room customization
            },

            // Sync state
            sync: {
                status: 'idle', // 'idle' | 'syncing' | 'error'
                lastSyncTime: null,
                error: null,
                pendingChanges: false,
                offlineQueue: []
            },

            // Network state
            network: {
                isOnline: navigator.onLine
            },

            // UI state
            ui: {
                authModalVisible: false,
                authModalMode: 'login', // 'login' | 'register'
                loadingVisible: false
            },

            // Engagement tracking
            engagement: {
                totalCompletions: 0,
                consecutiveDays: 0,
                firstVisit: null,
                lastVisit: null,
                visitCount: 0,
                hasSeenAuthPrompt: false,
                dismissedAuthPromptCount: 0
            }
        };

        /**
         * Load state from localStorage
         * Supports both anonymous and authenticated modes
         */
        function loadState() {
            try {
                // Check if we should redirect to landing page
                // Only redirect if NOT authenticated AND NOT coming from welcome.html with an action
                const authStateStr = localStorage.getItem('cleanStreak_authenticated_state');
                const urlParams = new URLSearchParams(window.location.search);
                const action = urlParams.get('action');

                if (!authStateStr && !action) {
                    window.location.href = 'welcome.html';
                    return;
                }

                // Try authenticated state first
                const authenticatedData = localStorage.getItem('cleanStreak_authenticated_state');
                if (authenticatedData) {
                    const data = JSON.parse(authenticatedData);

                    // Restore state
                    Object.assign(AppState.user, data.user || {});
                    Object.assign(AppState.streak, data.streak || {});
                    Object.assign(AppState.engagement, data.engagement || {});

                    AppState.user.isAuthenticated = true;
                    return;
                }

                // Fall back to anonymous state
                const anonymousData = localStorage.getItem('cleanStreak_anonymous_state');
                if (anonymousData) {
                    const data = JSON.parse(anonymousData);

                    Object.assign(AppState.streak, data.streak || {});
                    Object.assign(AppState.engagement, data.engagement || {});
                }

                // Track visit
                AppState.engagement.visitCount++;
                AppState.engagement.lastVisit = new Date().toISOString();
                if (!AppState.engagement.firstVisit) {
                    AppState.engagement.firstVisit = new Date().toISOString();
                }
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }

        /**
         * Save state to localStorage
         */
        function saveState() {
            try {
                if (AppState.user.isAuthenticated) {
                    // Save authenticated state
                    const data = {
                        user: AppState.user,
                        streak: AppState.streak,
                        engagement: AppState.engagement,
                        lastSyncTime: AppState.sync.lastSyncTime || new Date().toISOString()
                    };
                    localStorage.setItem('cleanStreak_authenticated_state', JSON.stringify(data));
                } else {
                    // Save anonymous state
                    const data = {
                        streak: AppState.streak,
                        engagement: AppState.engagement,
                        lastSyncTime: new Date().toISOString()
                    };
                    localStorage.setItem('cleanStreak_anonymous_state', JSON.stringify(data));
                }
            } catch (error) {
                console.error('Error saving state:', error);
            }
        }

        /**
         * Clear all persisted state
         */
        function clearState() {
            localStorage.removeItem('cleanStreak_anonymous_state');
            localStorage.removeItem('cleanStreak_authenticated_state');
        }

        /**
         * Update UI to reflect current authentication state
         */
        function updateAuthUI() {
            const userEmail = document.getElementById('userEmail');
            const loginButton = document.getElementById('loginButton');
            const logoutButton = document.getElementById('logoutButton');
            const settingsButton = document.getElementById('settingsButton');

            if (AppState.user.isAuthenticated && AppState.user.profile) {
                // Authenticated state
                userEmail.textContent = AppState.user.profile.email;
                userEmail.style.display = 'block';
                loginButton.style.display = 'none';
                logoutButton.style.display = 'block';
                settingsButton.style.display = 'block';
            } else {
                // Anonymous state
                userEmail.style.display = 'none';
                loginButton.style.display = 'block';
                logoutButton.style.display = 'none';
                settingsButton.style.display = 'none';
            }
        }

        // ============================================
        // DATA SYNCHRONIZATION FUNCTIONS (Step 28)
        // ============================================

        /**
         * Process offline queue - send queued actions to server
         * @returns {Promise<void>}
         */
        async function processOfflineQueue() {
            if (!AppState.user.isAuthenticated) return;
            if (!AppState.network.isOnline) return;
            if (AppState.sync.offlineQueue.length === 0) return;

            console.log(`Processing ${AppState.sync.offlineQueue.length} offline actions...`);

            const successfulActions = [];
            const failedActions = [];

            // Process each queued action
            for (const queuedAction of AppState.sync.offlineQueue) {
                try {
                    if (queuedAction.action === 'COMPLETE_TASK') {
                        await UserAPI.completeTask(queuedAction.payload.taskDescription);
                        successfulActions.push(queuedAction);
                        console.log('Synced offline task completion:', queuedAction.payload.taskDescription);
                    }
                    // Add more action types here as needed
                } catch (error) {
                    // Check if it's a 409 "already completed" error
                    const isAlreadyCompleted = error.response?.status === 409 ||
                                              error.message?.includes('already completed');

                    if (isAlreadyCompleted) {
                        // 409 means task is already completed - treat as success
                        successfulActions.push(queuedAction);
                        console.log('Task already completed (409), removing from queue:', queuedAction.payload.taskDescription);
                    } else {
                        // For other errors, retry up to 3 times
                        console.error('Failed to process offline action:', queuedAction, error);
                        queuedAction.retryCount = (queuedAction.retryCount || 0) + 1;

                        // Keep in queue if retry count < 3, otherwise drop it
                        if (queuedAction.retryCount < 3) {
                            failedActions.push(queuedAction);
                        } else {
                            console.warn('Dropping action after 3 failed retries:', queuedAction);
                        }
                    }
                }
            }

            // Update queue with only failed actions that should be retried
            AppState.sync.offlineQueue = failedActions;

            // Mark as having pending changes if queue is not empty
            AppState.sync.pendingChanges = failedActions.length > 0;

            console.log(`Offline queue processed: ${successfulActions.length} succeeded, ${failedActions.length} pending retry`);
        }

        /**
         * Push local changes to server
         * @returns {Promise<boolean>} Success status
         */
        async function pushLocalChangesToServer() {
            if (!AppState.user.isAuthenticated) return false;
            if (!AppState.network.isOnline) return false;

            try {
                // Check if there are local changes that need to be pushed
                // This is primarily for offline queue and any pending state changes

                // Process offline queue first
                await processOfflineQueue();

                // Additional sync logic could go here for other state changes
                // For now, task completions are the main sync point

                return true;
            } catch (error) {
                console.error('Error pushing local changes:', error);
                return false;
            }
        }

        /**
         * Fetch latest data from server and update local state
         * @returns {Promise<Object|null>} Server data or null on error
         */
        async function fetchServerData() {
            if (!AppState.user.isAuthenticated) return null;
            if (!AppState.network.isOnline) return null;

            try {
                // Fetch latest data from server (streaks, history, profile)
                const [streaksResponse, historyResponse, profileResponse] = await Promise.all([
                    UserAPI.getStreaks(),
                    UserAPI.getHistory(),
                    UserAPI.getProfile()
                ]);

                return {
                    streaks: streaksResponse,
                    history: historyResponse,
                    profile: profileResponse
                };
            } catch (error) {
                console.error('Error fetching server data:', error);
                return null;
            }
        }

        /**
         * Merge server data into local state
         * @param {Object} serverData - Data fetched from server
         */
        function mergeServerDataIntoLocalState(serverData) {
            if (!serverData) return;

            // Update streak data from server
            // Backend returns: { streaks: { current_streak, longest_streak, total_completions, last_completed } }
            if (serverData.streaks && serverData.streaks.streaks) {
                const streaks = serverData.streaks.streaks;

                // Server is the source of truth for streaks
                AppState.streak.current = streaks.current_streak || 0;
                AppState.streak.bestStreak = streaks.longest_streak || 0;

                // Set the last completion date if available
                if (streaks.last_completed) {
                    AppState.streak.lastCompletedDate = new Date(streaks.last_completed).toDateString();
                    console.log('Synced lastCompletedDate from server:', AppState.streak.lastCompletedDate);
                }
            }

            // Update profile data (including email_verified)
            // Backend returns: { user: { id, email, email_verified, ... }, stats: { ... } }
            if (serverData.profile && serverData.profile.user) {
                const user = serverData.profile.user;
                const stats = serverData.profile.stats || {};

                // Update profile in AppState
                if (!AppState.user.profile) {
                    AppState.user.profile = {};
                }
                AppState.user.profile.email_verified = user.email_verified || false;
                AppState.user.profile.email = user.email;
                AppState.user.profile.id = user.id;

                console.log('Synced email_verified from server:', user.email_verified);

                // Update engagement from stats
                AppState.engagement.totalCompletions = stats.totalCompletions || 0;
                AppState.engagement.consecutiveDays = AppState.streak.current;
            }

            // Update task history for analytics
            if (serverData.history && serverData.history.success && serverData.history.data) {
                const historyItems = serverData.history.data.history || [];
                AppState.task.history = historyItems.map(item => ({
                    taskDescription: item.taskDescription,
                    completedAt: item.completedAt,
                    streakDay: item.streakDay || 0
                }));
            }

            console.log('Server data merged into local state');
        }

        /**
         * Main sync function - bi-directional sync between client and server
         * This is the primary sync function called throughout the app
         */
        async function syncWithServer() {
            if (!AppState.user.isAuthenticated) {
                console.log('Sync skipped: user not authenticated');
                return;
            }

            if (!AppState.network.isOnline) {
                console.log('Sync skipped: offline');
                return;
            }

            if (AppState.sync.status === 'syncing') {
                console.log('Sync already in progress, skipping...');
                return;
            }

            try {
                console.log('Starting data synchronization...');
                AppState.sync.status = 'syncing';
                AppState.sync.error = null;

                // Step 1: Push local changes to server (includes offline queue)
                await pushLocalChangesToServer();

                // Step 2: Fetch latest data from server
                const serverData = await fetchServerData();

                // Step 3: Check for conflicts and resolve if necessary
                if (serverData && hasConflict(AppState, serverData)) {
                    console.log('Conflict detected - applying resolution rules...');

                    // Resolve the conflict
                    const resolved = resolveConflict(AppState, serverData);

                    // Apply resolved state to AppState
                    Object.assign(AppState.streak, resolved.streak);
                    Object.assign(AppState.engagement, resolved.engagement);

                    // Push resolved state back to server to ensure consistency
                    // This ensures the server has the resolved "winning" values
                    try {
                        await UserAPI.updatePreferences({
                            resolvedStreak: resolved.streak,
                            resolvedEngagement: resolved.engagement
                        });
                        console.log('Resolved state pushed to server');
                    } catch (pushError) {
                        console.warn('Failed to push resolved state to server:', pushError);
                        // Continue anyway - local state is updated
                    }
                } else if (serverData) {
                    // Step 4: No conflict - merge server data into local state normally
                    mergeServerDataIntoLocalState(serverData);
                }

                // Step 5: Update sync metadata
                AppState.sync.lastSyncTime = new Date().toISOString();
                AppState.sync.status = 'idle';
                AppState.sync.error = null;
                AppState.sync.pendingChanges = AppState.sync.offlineQueue.length > 0;

                // Step 6: Save updated state to localStorage
                saveState();

                console.log('Data synchronization completed successfully');
            } catch (error) {
                console.error('Sync error:', error);
                AppState.sync.status = 'error';
                AppState.sync.error = error.message;

                // Save state even on error to persist the error status
                saveState();
            }
        }

        /**
         * Background sync scheduler - runs periodically for authenticated users
         * Syncs every 5 minutes when user is active
         */
        let syncIntervalId = null;

        function startBackgroundSync() {
            // Clear any existing interval
            if (syncIntervalId) {
                clearInterval(syncIntervalId);
            }

            // Only start background sync for authenticated users
            if (!AppState.user.isAuthenticated) return;

            console.log('Starting background sync (5-minute intervals)');

            // Sync immediately
            syncWithServer();

            // Then sync every 5 minutes
            syncIntervalId = setInterval(() => {
                if (AppState.user.isAuthenticated && AppState.network.isOnline) {
                    syncWithServer();
                }
            }, 5 * 60 * 1000); // 5 minutes
        }

        function stopBackgroundSync() {
            if (syncIntervalId) {
                clearInterval(syncIntervalId);
                syncIntervalId = null;
                console.log('Background sync stopped');
            }
        }

        /**
         * Force an immediate sync (can be called manually)
         */
        async function forceSyncNow() {
            console.log('Force sync requested...');
            await syncWithServer();
        }

        /**
         * Migrate anonymous data to authenticated account
         */
        async function migrateAnonymousData() {
            // Check if there's anonymous data to migrate
            const anonymousData = localStorage.getItem('cleanStreak_anonymous_state');
            if (!anonymousData) return;

            try {
                const data = JSON.parse(anonymousData);

                // If anonymous user has a streak, merge it
                if (data.streak && data.streak.current > 0) {
                    // Server-side migration would happen here via API
                    // For now, keep the higher streak value
                    if (data.streak.current > AppState.streak.current) {
                        AppState.streak.current = data.streak.current;
                        AppState.streak.lastCompletedDate = data.streak.lastCompletedDate;
                    }
                    if (data.streak.bestStreak > AppState.streak.bestStreak) {
                        AppState.streak.bestStreak = data.streak.bestStreak;
                    }
                }

                // Merge engagement data
                if (data.engagement) {
                    AppState.engagement.totalCompletions += data.engagement.totalCompletions || 0;
                }

                // Clear anonymous data
                localStorage.removeItem('cleanStreak_anonymous_state');

                saveState();
            } catch (error) {
                console.error('Migration error:', error);
            }
        }

        // ============================================
        // CONFLICT RESOLUTION LOGIC (Step 29)
        // ============================================

        /**
         * Detect if there's a conflict between local and server state
         * @param {Object} localState - Current local AppState
         * @param {Object} serverData - Server data from fetchServerData()
         * @returns {boolean} True if conflict detected
         */
        function hasConflict(localState, serverData) {
            if (!serverData || !serverData.streaks || !serverData.streaks.success) {
                return false;
            }

            const serverStats = serverData.streaks.data?.stats || {};
            const serverStreaks = serverData.streaks.data?.streaks || [];

            // Check for streak value conflicts
            const streakDiffers = localState.streak.current !== (serverStats.totalCurrentStreak || 0);

            // Check for last completion date conflicts
            let lastCompletionDiffers = false;
            if (serverStreaks.length > 0) {
                const mostRecentServer = serverStreaks.reduce((latest, streak) => {
                    const streakDate = new Date(streak.lastCompletedAt);
                    const latestDate = latest ? new Date(latest) : new Date(0);
                    return streakDate > latestDate ? streak.lastCompletedAt : latest;
                }, null);

                if (mostRecentServer) {
                    const serverDateString = new Date(mostRecentServer).toDateString();
                    lastCompletionDiffers = localState.streak.lastCompletedDate !== serverDateString;
                }
            }

            // Check for best streak conflicts
            const bestStreakDiffers = localState.streak.bestStreak !== (serverStats.bestOverallStreak || 0);

            const hasConflict = streakDiffers || lastCompletionDiffers || bestStreakDiffers;

            if (hasConflict) {
                console.log('Conflict detected between local and server state', {
                    localCurrent: localState.streak.current,
                    serverCurrent: serverStats.totalCurrentStreak,
                    localLast: localState.streak.lastCompletedDate,
                    serverLast: mostRecentServer,
                    localBest: localState.streak.bestStreak,
                    serverBest: serverStats.bestOverallStreak
                });
            }

            return hasConflict;
        }

        /**
         * Resolve conflicts between local and server state
         * Implements the conflict resolution rules from state-management-design.md
         * @param {Object} localState - Current local AppState
         * @param {Object} serverData - Server data from fetchServerData()
         * @returns {Object} Resolved state to apply
         */
        function resolveConflict(localState, serverData) {
            console.log('Resolving conflict between local and server state...');

            const resolved = {
                streak: {},
                engagement: {}
            };

            const serverStats = serverData.streaks?.data?.stats || {};
            const serverStreaks = serverData.streaks?.data?.streaks || [];
            const serverProfile = serverData.profile?.data || {};
            const serverHistory = serverData.history?.data?.history || [];

            // ============================================
            // RULE 1: Server wins for historical data (source of truth)
            // ============================================
            resolved.streak.history = serverStreaks.map(streak =>
                new Date(streak.lastCompletedAt).toDateString()
            );

            // ============================================
            // RULE 2: Higher streak value wins
            // ============================================
            const serverCurrentStreak = serverStats.totalCurrentStreak || 0;
            const localCurrentStreak = localState.streak.current || 0;

            resolved.streak.current = Math.max(serverCurrentStreak, localCurrentStreak);

            console.log('Streak resolution: server=' + serverCurrentStreak + ', local=' + localCurrentStreak + ', resolved=' + resolved.streak.current);

            // ============================================
            // RULE 3: Most recent completion date wins
            // ============================================
            let serverLastDate = null;
            if (serverStreaks.length > 0) {
                const mostRecent = serverStreaks.reduce((latest, streak) => {
                    const streakDate = new Date(streak.lastCompletedAt);
                    const latestDate = latest ? new Date(latest) : new Date(0);
                    return streakDate > latestDate ? streak.lastCompletedAt : latest;
                }, null);

                if (mostRecent) {
                    serverLastDate = new Date(mostRecent).toDateString();
                }
            }

            const localLastDate = localState.streak.lastCompletedDate;

            if (serverLastDate && localLastDate) {
                const serverDate = new Date(serverLastDate);
                const localDate = new Date(localLastDate);
                resolved.streak.lastCompletedDate = localDate > serverDate ? localLastDate : serverLastDate;
            } else {
                resolved.streak.lastCompletedDate = serverLastDate || localLastDate;
            }

            console.log('Last completion date resolution: server=' + serverLastDate + ', local=' + localLastDate + ', resolved=' + resolved.streak.lastCompletedDate);

            // ============================================
            // RULE 4: Higher best streak wins
            // ============================================
            const serverBestStreak = serverStats.bestOverallStreak || 0;
            const localBestStreak = localState.streak.bestStreak || 0;

            resolved.streak.bestStreak = Math.max(serverBestStreak, localBestStreak);

            console.log('Best streak resolution: server=' + serverBestStreak + ', local=' + localBestStreak + ', resolved=' + resolved.streak.bestStreak);

            // ============================================
            // RULE 5: Merge engagement metrics (server as primary source)
            // ============================================
            // For total completions, use server data as it's the source of truth
            resolved.engagement.totalCompletions = serverProfile.stats?.totalCompletions || localState.engagement.totalCompletions || 0;

            // Update consecutive days to match current streak
            resolved.engagement.consecutiveDays = resolved.streak.current;

            // Keep earliest first visit
            const localFirst = localState.engagement.firstVisit ? new Date(localState.engagement.firstVisit) : null;
            const serverFirst = serverProfile.createdAt ? new Date(serverProfile.createdAt) : null;

            if (localFirst && serverFirst) {
                resolved.engagement.firstVisit = localFirst < serverFirst
                    ? localState.engagement.firstVisit
                    : serverProfile.createdAt;
            } else {
                resolved.engagement.firstVisit = localState.engagement.firstVisit || serverProfile.createdAt;
            }

            // Preserve local engagement tracking flags (these are client-side only)
            resolved.engagement.lastVisit = localState.engagement.lastVisit;
            resolved.engagement.visitCount = localState.engagement.visitCount;
            resolved.engagement.hasSeenAuthPrompt = localState.engagement.hasSeenAuthPrompt;
            resolved.engagement.dismissedAuthPromptCount = localState.engagement.dismissedAuthPromptCount;

            console.log('Conflict resolution complete:', resolved);

            return resolved;
        }

        // ============================================
        // OFFLINE FUNCTIONALITY ENHANCEMENTS (Step 30)
        // ============================================

        /**
         * Show notification toast
         * @param {string} message - Message to display
         * @param {string} type - Type of notification: success, info, warning, error
         * @param {number} duration - Duration in milliseconds (default: 4000)
         */
        function showNotification(message, type = 'info', duration = 4000) {
            const toast = document.getElementById('notificationToast');
            const icon = document.getElementById('toastIcon');
            const messageEl = document.getElementById('toastMessage');

            // Set icon based on type
            const icons = {
                success: '&#10004;',
                info: '&#9432;',
                warning: '&#9888;',
                error: '&#10006;'
            };

            icon.innerHTML = icons[type] || icons.info;
            messageEl.textContent = message;

            // Reset classes
            toast.className = 'notification-toast show ' + type;

            // Auto-hide after duration
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        /**
         * Update connection status indicator in UI
         */
        function updateConnectionStatus() {
            const offlineIndicator = document.getElementById('offlineIndicator');

            if (AppState.network.isOnline) {
                // Online state
                offlineIndicator.classList.remove('show');
            } else {
                // Offline state
                offlineIndicator.classList.add('show');
            }
        }

        /**
         * Update sync queue indicator
         */
        function updateSyncQueueIndicator() {
            const syncQueueIndicator = document.getElementById('syncQueueIndicator');
            const syncQueueText = document.getElementById('syncQueueText');

            const queueLength = AppState.sync.offlineQueue.length;

            if (queueLength > 0) {
                syncQueueIndicator.classList.add('show');
                syncQueueText.textContent = queueLength === 1
                    ? '1 action pending sync...'
                    : `${queueLength} actions pending sync...`;
            } else {
                syncQueueIndicator.classList.remove('show');
            }
        }

        /**
         * Handle when app goes offline
         */
        function handleOffline() {
            console.log('Network status: OFFLINE');
            AppState.network.isOnline = false;
            updateConnectionStatus();

            // Only show notification if user is authenticated (anonymous users don't sync anyway)
            if (AppState.user.isAuthenticated) {
                showNotification('You\'re offline. Changes will sync when reconnected.', 'warning', 6000);
            }

            saveState();
        }

        /**
         * Handle when app comes back online
         */
        async function handleOnline() {
            console.log('Network status: ONLINE');
            AppState.network.isOnline = true;
            updateConnectionStatus();

            // Show notification
            if (AppState.user.isAuthenticated) {
                showNotification('Connection restored! Syncing data...', 'success', 3000);
            }

            // Process offline queue if user is authenticated
            if (AppState.user.isAuthenticated) {
                const queueLength = AppState.sync.offlineQueue.length;

                if (queueLength > 0) {
                    console.log(`Processing ${queueLength} queued actions after reconnection...`);

                    // Process the offline queue
                    await processOfflineQueue();

                    // Sync with server to get latest data
                    await syncWithServer();

                    // Update queue indicator
                    updateSyncQueueIndicator();

                    // Show success notification
                    const remainingQueue = AppState.sync.offlineQueue.length;
                    if (remainingQueue === 0) {
                        showNotification('All changes synced successfully!', 'success', 3000);
                    } else if (remainingQueue < queueLength) {
                        showNotification(`${queueLength - remainingQueue} of ${queueLength} changes synced. ${remainingQueue} pending retry.`, 'warning', 4000);
                    }
                } else {
                    // Just sync to get latest server data
                    await syncWithServer();
                }
            }

            saveState();
        }

        /**
         * Enhanced queue processing with better error handling
         */
        async function processOfflineQueueEnhanced() {
            if (!AppState.user.isAuthenticated) return;
            if (!AppState.network.isOnline) return;
            if (AppState.sync.offlineQueue.length === 0) return;

            console.log(`Processing ${AppState.sync.offlineQueue.length} offline actions...`);

            const successfulActions = [];
            const failedActions = [];

            // Update indicator at start
            updateSyncQueueIndicator();

            // Process each queued action
            for (const queuedAction of AppState.sync.offlineQueue) {
                try {
                    if (queuedAction.action === 'COMPLETE_TASK') {
                        await UserAPI.completeTask(queuedAction.payload.taskDescription);
                        successfulActions.push(queuedAction);
                        console.log('Synced offline task completion:', queuedAction.payload.taskDescription);
                    }
                    // Add more action types here as needed
                } catch (error) {
                    console.error('Failed to process offline action:', queuedAction, error);
                    queuedAction.retryCount = (queuedAction.retryCount || 0) + 1;

                    // Keep in queue if retry count < 3, otherwise drop it
                    if (queuedAction.retryCount < 3) {
                        failedActions.push(queuedAction);
                    } else {
                        console.warn('Dropping action after 3 failed retries:', queuedAction);
                    }
                }
            }

            // Update queue with only failed actions that should be retried
            AppState.sync.offlineQueue = failedActions;

            // Mark as having pending changes if queue is not empty
            AppState.sync.pendingChanges = failedActions.length > 0;

            // Update indicator after processing
            updateSyncQueueIndicator();

            // Save state
            saveState();

            console.log(`Offline queue processed: ${successfulActions.length} succeeded, ${failedActions.length} pending retry`);

            return {
                succeeded: successfulActions.length,
                failed: failedActions.length
            };
        }

        /**
         * Check if app is truly online by pinging the API
         * @returns {Promise<boolean>} True if server is reachable
         */
        async function checkServerConnectivity() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    signal: AbortSignal.timeout(5000) // 5 second timeout
                });

                return response.ok;
            } catch (error) {
                console.log('Server connectivity check failed:', error.message);
                return false;
            }
        }

        /**
         * Periodic connectivity check for authenticated users
         * Runs every 30 seconds to detect server availability
         */
        let connectivityCheckInterval = null;

        function startConnectivityMonitoring() {
            // Clear any existing interval
            if (connectivityCheckInterval) {
                clearInterval(connectivityCheckInterval);
            }

            // Only monitor if user is authenticated
            if (!AppState.user.isAuthenticated) return;

            console.log('Starting connectivity monitoring');

            // Check every 30 seconds
            connectivityCheckInterval = setInterval(async () => {
                if (AppState.network.isOnline && AppState.user.isAuthenticated) {
                    const serverReachable = await checkServerConnectivity();

                    if (!serverReachable) {
                        // Server is unreachable even though browser thinks we're online
                        console.log('Server unreachable despite online status');
                        // Don't change network status, but log for debugging
                    } else if (AppState.sync.offlineQueue.length > 0) {
                        // Server is reachable and we have queued actions - try to sync
                        console.log('Server reachable with pending queue - attempting sync');
                        await processOfflineQueueEnhanced();
                        await syncWithServer();
                    }
                }
            }, 30000); // 30 seconds
        }

        function stopConnectivityMonitoring() {
            if (connectivityCheckInterval) {
                clearInterval(connectivityCheckInterval);
                connectivityCheckInterval = null;
                console.log('Connectivity monitoring stopped');
            }
        }

        // ============================================
        // LEGACY COMPATIBILITY LAYER
        // ============================================
        // Maintain backward compatibility with existing code

        Object.defineProperty(window, 'currentStreak', {
            get() { return AppState.streak.current; },
            set(value) { AppState.streak.current = value; }
        });

        Object.defineProperty(window, 'lastCompletedDate', {
            get() { return AppState.streak.lastCompletedDate; },
            set(value) { AppState.streak.lastCompletedDate = value; }
        });

        // ============================================
        // CORE APPLICATION FUNCTIONS
        // ============================================

        function getTodaysTask() {
            const today = new Date();
            const dayOfMonth = today.getDate();
            return cleaningTasks[(dayOfMonth - 1) % cleaningTasks.length];
        }

        /**
         * Get legacy task for users without room configuration
         * Uses day-of-month rotation for backward compatibility
         */
        function getLegacyTask() {
            const today = new Date();
            const dayOfMonth = today.getDate();
            const taskDescription = cleaningTasks[(dayOfMonth - 1) % cleaningTasks.length];

            return {
                description: taskDescription,
                isLegacy: true
            };
        }

        /**
         * Fetch current task from rotation API or fallback to legacy
         * @returns {Promise<object>} Current task object
         */
        async function fetchCurrentTask() {
            try {
                // Check if user has configured rooms
                if (!AppState.user.hasConfiguredRooms) {
                    // Fallback to legacy system
                    return getLegacyTask();
                }

                // Fetch from rotation
                const response = await TaskAPI.getCurrentTask();

                if (response.task) {
                    // Cache in AppState
                    AppState.currentTask = {
                        id: response.task.id,
                        description: response.task.description,
                        taskType: response.task.task_type,
                        room: response.task.room,
                        pillarType: response.task.pillar_type,
                        keystoneType: response.task.keystone_type,
                        position: response.task.position,
                        totalTasks: response.task.total_tasks
                    };

                    return AppState.currentTask;
                }
            } catch (error) {
                console.error('Failed to fetch current task:', error);

                // Fallback to legacy
                return getLegacyTask();
            }
        }

        function getTodayString() {
            const today = new Date();
            return today.toDateString();
        }

        /**
         * Helper function to capitalize first letter
         */
        function capitalizeFirst(str) {
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        /**
         * Display current task with progress indicators and badges
         * Handles both rotation-based and legacy tasks
         */
        /**
         * Phase 7: Check migration status and show banner for users without rooms
         * Called after user authentication is verified
         */
        async function checkMigrationStatus() {
            if (!AppState.user.isAuthenticated) return;

            // Check if banner was previously dismissed
            const dismissed = localStorage.getItem('migration_banner_dismissed');
            if (dismissed === 'true') return;

            try {
                const roomsResponse = await RoomAPI.getUserRooms();

                if (roomsResponse.rooms.length === 0) {
                    // User has no rooms - show banner
                    document.getElementById('migrationBanner').style.display = 'block';
                    AppState.user.hasConfiguredRooms = false;
                } else {
                    AppState.user.hasConfiguredRooms = true;
                }
            } catch (error) {
                console.error('Failed to check migration status:', error);
            }
        }

        /**
         * Phase 7: Dismiss migration banner
         * Hides banner and stores dismissal in localStorage
         */
        function dismissMigrationBanner() {
            document.getElementById('migrationBanner').style.display = 'none';
            localStorage.setItem('migration_banner_dismissed', 'true');
        }

        function displayCurrentTask() {
            const task = AppState.currentTask;

            if (!task) return;

            // Update description
            document.getElementById('taskText').textContent = task.description;

            if (task.isLegacy) {
                // Legacy mode
                document.getElementById('taskProgress').style.display = 'none';
                document.getElementById('taskContext').style.display = 'none';
                document.getElementById('legacyPrompt').style.display = 'block';
            } else {
                // Rotation mode
                document.getElementById('taskProgress').style.display = 'block';
                document.getElementById('legacyPrompt').style.display = 'none';

                // Update progress
                const percentage = (task.position / task.totalTasks) * 100;
                document.querySelector('.progress-fill').style.width = `${percentage}%`;
                document.getElementById('currentPosition').textContent = task.position;
                document.getElementById('totalTasks').textContent = task.totalTasks;

                // Update context badge
                const badge = document.getElementById('taskBadge');
                if (task.taskType === 'pillar') {
                    badge.textContent = `${task.room.name} - ${capitalizeFirst(task.pillarType)}`;
                    badge.className = 'badge pillar';
                } else {
                    badge.textContent = 'Keystone Task';
                    badge.className = 'badge keystone';
                }
                document.getElementById('taskContext').style.display = 'block';
            }
        }

        async function updateDisplay() {
            const todayString = getTodayString();

            // Fetch and display current task
            const task = await fetchCurrentTask();
            AppState.currentTask = task;
            displayCurrentTask();

            // Update streak display
            if (AppState.streak.lastCompletedDate === todayString) {
                document.getElementById('streakText').textContent = `ðŸ”¥ Current streak: ${AppState.streak.current} days`;
                document.getElementById('doneButton').textContent = 'Completed!';
                document.getElementById('doneButton').classList.add('completed');
                document.getElementById('doneButton').disabled = true;
                document.getElementById('completedMessage').style.display = 'block';
            } else {
                document.getElementById('streakText').textContent = `ðŸ”¥ Current streak: ${AppState.streak.current} days`;
                document.getElementById('doneButton').textContent = 'Done!';
                document.getElementById('doneButton').classList.remove('completed');
                document.getElementById('doneButton').disabled = false;
                document.getElementById('completedMessage').style.display = 'none';
            }
        }

        /**
         * Validate user session on app initialization
         * Verifies JWT token is valid by calling the API
         * Handles token refresh automatically if needed
         */
        async function validateSession() {
            if (!AppState.user.isAuthenticated) {
                console.log('No authenticated session to validate');
                return;
            }

            console.log('Validating session...');

            try {
                // Try to fetch user profile to validate session
                const profileData = await UserAPI.getProfile();

                // Session is valid - update profile data
                AppState.user.profile = profileData.user || profileData;
                AppState.user.email = profileData.user?.email || profileData.email;
                saveState();

                console.log('Session validated successfully');
            } catch (error) {
                console.error('Session validation failed:', error);

                // If we get here, either:
                // 1. Token refresh was attempted and failed (handleSessionExpired was called)
                // 2. Some other error occurred
                // In either case, the user has been logged out by the error handler
            }
        }

        /**
         * Load/reload dashboard data after onboarding or configuration changes
         * Refreshes the current task display to show rotation-based tasks
         */
        async function loadDashboard() {
            try {
                // Check if user has configured rooms
                const roomsResponse = await RoomAPI.getUserRooms();
                const hasRooms = roomsResponse.rooms && roomsResponse.rooms.length > 0;

                // Update app state
                AppState.user.hasConfiguredRooms = hasRooms;
                saveState();

                // Refresh the task display
                await updateDisplay();

                console.log('Dashboard loaded successfully', { hasRooms });
            } catch (error) {
                console.error('Failed to load dashboard:', error);
                // Still try to update display even if room check fails
                await updateDisplay();
            }
        }

        async function completeTask() {
            const task = AppState.currentTask;
            const todayString = getTodayString();

            if (!task) {
                showNotification('No task to complete', 'error');
                return;
            }

            if (AppState.streak.lastCompletedDate === todayString) {
                return;
            }

            try {
                // Animation
                document.querySelector('.container').classList.add('completion-animation');
                setTimeout(() => {
                    document.querySelector('.container').classList.remove('completion-animation');
                }, 600);

                // Prepare completion data
                const completionData = {
                    taskName: task.description,
                    completionDate: new Date().toISOString().split('T')[0],
                    notes: '',
                    task_rotation_id: task.isLegacy ? null : task.id
                };

                // If authenticated, save to server
                if (AppState.user.isAuthenticated) {
                    try {
                        const response = await UserAPI.completeTask(
                            completionData.taskName,
                            completionData.task_rotation_id
                        );

                        if (response.success) {
                            // Update streak from server response
                            AppState.streak.current = response.streak.current_streak;
                            AppState.streak.bestStreak = response.streak.longest_streak;
                            AppState.streak.lastCompletedDate = todayString;

                            // Update engagement tracking
                            AppState.engagement.totalCompletions++;
                            AppState.engagement.consecutiveDays = AppState.streak.current;

                            // If rotation-based, load next task
                            if (response.next_task) {
                                AppState.currentTask = {
                                    id: response.next_task.id,
                                    description: response.next_task.description,
                                    taskType: response.next_task.task_type,
                                    room: response.next_task.room,
                                    pillarType: response.next_task.pillar_type,
                                    keystoneType: response.next_task.keystone_type,
                                    position: response.next_task.position,
                                    totalTasks: response.next_task.total_tasks
                                };
                                displayCurrentTask();
                                showNotification(`Great job! Next: ${response.next_task.description}`, 'success', 5000);
                            } else {
                                // Legacy mode - will change tomorrow
                                showNotification('Task completed! See you tomorrow.', 'success', 4000);
                            }

                            // Save to localStorage
                            saveState();

                            // Update streak display only (don't re-fetch task which would overwrite next_task)
                            document.getElementById('streakText').textContent = `ðŸ”¥ Current streak: ${AppState.streak.current} days`;
                            document.getElementById('doneButton').textContent = 'Completed!';
                            document.getElementById('doneButton').classList.add('completed');
                            document.getElementById('doneButton').disabled = true;
                            document.getElementById('completedMessage').style.display = 'block';
                        }
                    } catch (error) {
                        console.error('Error saving to server:', error);

                        // Fallback to local completion
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        const yesterdayString = yesterday.toDateString();

                        if (AppState.streak.lastCompletedDate === yesterdayString || AppState.streak.current === 0) {
                            AppState.streak.current++;
                        } else {
                            AppState.streak.current = 1;
                        }

                        AppState.streak.lastCompletedDate = todayString;

                        // Update engagement tracking
                        AppState.engagement.totalCompletions++;
                        AppState.engagement.consecutiveDays = AppState.streak.current;

                        if (AppState.streak.current > AppState.streak.bestStreak) {
                            AppState.streak.bestStreak = AppState.streak.current;
                        }

                        // Queue for offline sync
                        AppState.sync.offlineQueue.push({
                            action: 'COMPLETE_TASK',
                            payload: completionData,
                            timestamp: new Date().toISOString(),
                            retryCount: 0
                        });

                        // Update sync queue indicator
                        updateSyncQueueIndicator();

                        // Show notification about queued action
                        if (!AppState.network.isOnline) {
                            showNotification('Task saved locally. Will sync when online.', 'info', 4000);
                        } else {
                            showNotification('Sync failed. Task queued for retry.', 'warning', 4000);
                        }

                        saveState();
                        updateDisplay();
                    }
                } else {
                    // Anonymous mode - local storage only
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayString = yesterday.toDateString();

                    if (AppState.streak.lastCompletedDate === yesterdayString || AppState.streak.current === 0) {
                        AppState.streak.current++;
                    } else {
                        AppState.streak.current = 1;
                    }

                    AppState.streak.lastCompletedDate = todayString;

                    // Update engagement tracking
                    AppState.engagement.totalCompletions++;
                    AppState.engagement.consecutiveDays = AppState.streak.current;

                    if (AppState.streak.current > AppState.streak.bestStreak) {
                        AppState.streak.bestStreak = AppState.streak.current;
                    }

                    saveState();
                    updateDisplay();
                    showNotification('Task completed!', 'success', 3000);
                }
            } catch (error) {
                console.error('Error completing task:', error);
                showNotification('Failed to complete task. Please try again.', 'error', 4000);
            }
        }

        // ============================================
        // AUTHENTICATION LOGIC (Step 27)
        // ============================================

        /**
         * Show authentication modal
         * @param {string} mode - 'login' or 'register'
         */
        function showAuthModal(mode = 'login') {
            AppState.ui.authModalMode = mode;
            AppState.ui.authModalVisible = true;

            const overlay = document.getElementById('authOverlay');
            const loginForm = document.getElementById('loginForm');
            const registerForm = document.getElementById('registerForm');

            if (mode === 'login') {
                loginForm.style.display = 'block';
                registerForm.style.display = 'none';
            } else {
                loginForm.style.display = 'none';
                registerForm.style.display = 'block';
            }

            overlay.style.display = 'flex';

            // Clear any previous errors
            document.getElementById('loginError').classList.remove('show');
            document.getElementById('registerError').classList.remove('show');
        }

        /**
         * Hide authentication modal
         */
        function hideAuthModal() {
            AppState.ui.authModalVisible = false;
            document.getElementById('authOverlay').style.display = 'none';

            // Clear form fields
            document.getElementById('loginFormElement').reset();
            document.getElementById('registerFormElement').reset();
        }

        /**
         * Show error message in auth form
         * @param {string} formType - 'login' or 'register'
         * @param {string} message - Error message to display
         */
        function showAuthError(formType, message) {
            const errorElement = document.getElementById(`${formType}Error`);
            errorElement.textContent = message;
            errorElement.classList.add('show');
        }

        // ============================================
        // EMAIL VERIFICATION LOGIC
        // ============================================

        /**
         * Show verification banner for unverified users
         */
        function showVerificationBanner() {
            const banner = document.getElementById('verificationBanner');
            banner.classList.add('show');
            document.body.classList.add('banner-visible');
        }

        /**
         * Hide verification banner
         */
        function hideVerificationBanner() {
            const banner = document.getElementById('verificationBanner');
            banner.classList.remove('show');
            document.body.classList.remove('banner-visible');
        }

        /**
         * Show verification modal with dynamic content
         * @param {string} state - 'loading' | 'success' | 'error'
         * @param {object} data - Additional data for the modal
         */
        function showVerificationModal(state, data = {}) {
            const overlay = document.getElementById('emailVerificationOverlay');
            const content = document.getElementById('verificationContent');

            let html = '';

            if (state === 'loading') {
                html = `
                    <div class="verification-icon loading">â³</div>
                    <h2 class="verification-title">Verifying Email...</h2>
                    <div class="verification-spinner"></div>
                    <p class="verification-message">Please wait while we verify your email address.</p>
                `;
            } else if (state === 'success') {
                html = `
                    <div class="verification-icon success">âœ“</div>
                    <h2 class="verification-title">Email Verified!</h2>
                    <p class="verification-message">
                        Your email address has been successfully verified. You now have full access to your account.
                    </p>
                    <div class="verification-actions">
                        <button class="verification-btn primary" onclick="closeVerificationModal()">
                            Continue
                        </button>
                    </div>
                `;
            } else if (state === 'error') {
                html = `
                    <div class="verification-icon error">âœ—</div>
                    <h2 class="verification-title">Verification Failed</h2>
                    <p class="verification-message">
                        ${data.message || 'The verification link is invalid or has expired. Please request a new verification email.'}
                    </p>
                    <div class="verification-actions">
                        <button class="verification-btn primary" onclick="handleResendFromModal()">
                            Resend Verification Email
                        </button>
                        <button class="verification-btn secondary" onclick="closeVerificationModal()">
                            Close
                        </button>
                    </div>
                `;
            }

            content.innerHTML = html;
            overlay.classList.add('show');
        }

        /**
         * Close verification modal
         */
        function closeVerificationModal() {
            const overlay = document.getElementById('emailVerificationOverlay');
            overlay.classList.remove('show');

            // Reload page to refresh user state
            window.location.href = window.location.origin + window.location.pathname;
        }

        /**
         * Handle email verification from URL token
         */
        async function handleEmailVerification() {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');

            if (!token) {
                return; // No token, nothing to do
            }

            console.log('Email verification token detected, verifying...');
            showVerificationModal('loading');

            try {
                const result = await AuthAPI.verifyEmail(token);
                console.log('Email verified successfully:', result);

                // Update user state if logged in
                if (AppState.user.profile) {
                    AppState.user.profile.email_verified = true;
                    saveState();

                    // Refresh profile from server to ensure banner stays hidden
                    try {
                        const profileData = await UserAPI.getProfile();
                        AppState.user.profile.email_verified = profileData.user?.email_verified || profileData.email_verified || true;
                        saveState();
                    } catch (error) {
                        console.log('Could not refresh profile, but verification succeeded');
                    }
                }

                // Hide banner if visible
                hideVerificationBanner();

                // Show success modal
                showVerificationModal('success');

            } catch (error) {
                console.error('Email verification failed:', error);
                showVerificationModal('error', {
                    message: error.message || 'Verification failed. Please try again.'
                });
            }
        }

        /**
         * Handle resend verification email
         */
        async function handleResendVerification() {
            const email = AppState.user.profile?.email;

            if (!email) {
                showNotification('Please log in to resend verification email', 'error');
                return;
            }

            const button = document.getElementById('resendVerificationBtn');
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = 'Sending...';

            try {
                await AuthAPI.resendVerification(email);
                showNotification('Verification email sent! Please check your inbox.', 'success', 5000);
                console.log('Verification email resent to:', email);

                // Optionally hide banner temporarily
                setTimeout(() => {
                    button.disabled = false;
                    button.textContent = originalText;
                }, 3000);

            } catch (error) {
                console.error('Failed to resend verification email:', error);
                showNotification('Failed to send verification email. Please try again later.', 'error');
                button.disabled = false;
                button.textContent = originalText;
            }
        }

        /**
         * Handle resend from verification modal
         */
        async function handleResendFromModal() {
            const email = AppState.user.profile?.email || prompt('Please enter your email address:');

            if (!email) {
                return;
            }

            showVerificationModal('loading');

            try {
                await AuthAPI.resendVerification(email);
                closeVerificationModal();
                showNotification('Verification email sent! Please check your inbox.', 'success', 5000);
                console.log('Verification email resent to:', email);

            } catch (error) {
                console.error('Failed to resend verification email:', error);
                showVerificationModal('error', {
                    message: 'Failed to send verification email. Please try again later.'
                });
            }
        }

        /**
         * Check if user needs to verify email and show banner
         */
        function checkAndShowVerificationBanner() {
            const user = AppState.user.profile;

            if (user && user.email && !user.email_verified) {
                console.log('User email not verified, showing banner');
                showVerificationBanner();
            } else {
                hideVerificationBanner();
            }
        }

        // ============================================
        // ONBOARDING LOGIC
        // ============================================

        /**
         * Onboarding state
         */
        const OnboardingState = {
            rooms: [],
            isConfiguring: false
        };

        /**
         * Room type icons mapping
         */
        const roomIcons = {
            living_room: 'ðŸ›‹ï¸',
            bedroom: 'ðŸ›ï¸',
            kitchen: 'ðŸ³',
            bathroom: 'ðŸš¿',
            office: 'ðŸ’¼',
            dining_room: 'ðŸ½ï¸',
            laundry: 'ðŸ§º',
            garage: 'ðŸš—'
        };

        /**
         * Format room type for display
         */
        function formatRoomType(roomType) {
            return roomType.split('_').map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        /**
         * Generate a unique room name based on room type and existing rooms
         * If the default name (e.g., "Living Room") is already taken, appends a number
         * @param {string} roomType - The room type (e.g., "living_room")
         * @param {Array} existingRooms - Array of existing room objects
         * @returns {string} A unique room name
         */
        function generateUniqueRoomName(roomType, existingRooms) {
            const baseName = formatRoomType(roomType);
            const existingNames = existingRooms.map(room => room.custom_name.toLowerCase());

            // Check if the base name is available
            if (!existingNames.includes(baseName.toLowerCase())) {
                return baseName;
            }

            // If base name exists, find the next available number
            let counter = 2;
            let uniqueName;

            do {
                uniqueName = `${baseName} ${counter}`;
                counter++;
            } while (existingNames.includes(uniqueName.toLowerCase()));

            return uniqueName;
        }

        /**
         * Show onboarding modal
         */
        function showOnboardingModal() {
            const overlay = document.getElementById('onboardingOverlay');
            overlay.style.display = 'flex';

            // Load any existing rooms
            loadUserRooms();
        }

        /**
         * Hide onboarding modal
         */
        function hideOnboardingModal() {
            const overlay = document.getElementById('onboardingOverlay');
            overlay.style.display = 'none';

            // Reset form
            document.getElementById('roomForm').reset();
        }

        /**
         * Load user's configured rooms
         */
        async function loadUserRooms() {
            try {
                const response = await RoomAPI.getUserRooms();
                OnboardingState.rooms = response.rooms || [];
                renderRoomsList();

                // Enable finish button if rooms exist
                const finishBtn = document.getElementById('finishOnboarding');
                finishBtn.disabled = OnboardingState.rooms.length === 0;
            } catch (error) {
                console.error('Failed to load rooms:', error);
                // Show empty state
                OnboardingState.rooms = [];
                renderRoomsList();
            }
        }

        /**
         * Render rooms list
         */
        function renderRoomsList() {
            const container = document.getElementById('roomsContainer');

            if (OnboardingState.rooms.length === 0) {
                container.innerHTML = '<p class="empty-state">No rooms added yet. Add your first room below!</p>';
                return;
            }

            container.innerHTML = OnboardingState.rooms.map(room => `
                <div class="room-card" data-room-id="${room.id}">
                    <div class="room-header">
                        <span class="room-icon">${roomIcons[room.room_type] || 'ðŸ '}</span>
                        <span class="room-name">${room.custom_name}</span>
                        <span class="room-type-badge">${formatRoomType(room.room_type)}</span>
                    </div>
                    <div class="room-details">
                        <span class="glass-indicator">${room.has_glass ? 'ðŸªŸ Has glass' : 'No glass'}</span>
                    </div>
                    <div class="room-actions">
                        <button class="delete-room-btn" data-room-id="${room.id}">Delete</button>
                    </div>
                </div>
            `).join('');

            // Add delete event listeners
            container.querySelectorAll('.delete-room-btn').forEach(btn => {
                btn.addEventListener('click', handleDeleteRoom);
            });
        }

        /**
         * Handle room form submission
         */
        async function handleRoomFormSubmit(event) {
            event.preventDefault();

            const roomType = document.getElementById('roomType').value;
            let customName = document.getElementById('customRoomName').value.trim();

            // If custom name is empty, generate a unique name based on room type
            if (!customName) {
                customName = generateUniqueRoomName(roomType, OnboardingState.rooms);
            }

            const roomData = {
                roomType,
                customName,
                hasGlass: document.getElementById('hasGlass').checked
            };

            try {
                const response = await RoomAPI.createRoom(roomData);

                if (response.success && response.room) {
                    // Add to state
                    OnboardingState.rooms.push(response.room);

                    // Re-render list
                    renderRoomsList();

                    // Enable finish button
                    document.getElementById('finishOnboarding').disabled = false;

                    // Reset form
                    event.target.reset();

                    showNotification('Room added successfully!', 'success', 2000);
                }
            } catch (error) {
                console.error('Failed to add room:', error);
                showNotification(error.message || 'Failed to add room. Please try again.', 'error', 3000);
            }
        }

        /**
         * Handle room deletion
         */
        async function handleDeleteRoom(event) {
            const roomId = event.target.dataset.roomId;

            if (!confirm('Are you sure you want to delete this room?')) {
                return;
            }

            try {
                await RoomAPI.deleteRoom(roomId);

                // Remove from state
                OnboardingState.rooms = OnboardingState.rooms.filter(r => r.id !== roomId);

                // Re-render
                renderRoomsList();

                // Disable finish button if no rooms left
                if (OnboardingState.rooms.length === 0) {
                    document.getElementById('finishOnboarding').disabled = true;
                }

                showNotification('Room deleted successfully!', 'success', 2000);
            } catch (error) {
                console.error('Failed to delete room:', error);
                showNotification(error.message || 'Failed to delete room.', 'error', 3000);
            }
        }

        /**
         * Handle finish onboarding - generate rotation
         */
        async function handleFinishOnboarding() {
            if (OnboardingState.rooms.length === 0) {
                showNotification('Please add at least one room first.', 'warning', 3000);
                return;
            }

            try {
                // Close room onboarding modal
                hideOnboardingModal();

                // Update app state
                AppState.user.hasConfiguredRooms = true;
                saveState();

                // Show keystone onboarding next
                await openKeystoneOnboardingModal();

            } catch (error) {
                console.error('Onboarding error:', error);
                showNotification(error.message || 'An error occurred. Please try again.', 'error', 3000);
            }
        }

        /**
         * Handle skip onboarding
         */
        function handleSkipOnboarding() {
            if (confirm('You can configure your rooms anytime in Settings. Continue with default tasks?')) {
                hideOnboardingModal();
                AppState.user.hasConfiguredRooms = false;
                saveState();
                showNotification('You can set up rooms anytime!', 'info', 3000);
            }
        }

        // ============================================
        // KEYSTONE ONBOARDING FUNCTIONS
        // ============================================

        // Keystone fixture templates (used to generate per-room keystones)
        const KEYSTONE_FIXTURE_TEMPLATES = {
            bathroom: [
                {
                    type: 'toilet',
                    name: (roomName) => `Scrub and disinfect ${roomName} toilet`,
                    description: 'High-traffic bathroom fixture - keep it fresh and sanitary'
                },
                {
                    type: 'sink',
                    name: (roomName) => `Clean ${roomName} sink`,
                    description: 'Personal hygiene area - keep counters and fixtures spotless'
                },
                {
                    type: 'shower',
                    name: (roomName) => `Scrub ${roomName} shower/tub`,
                    description: 'Moisture-prone area - prevent mold and soap scum'
                }
            ],
            kitchen: [
                {
                    type: 'sink',
                    name: (roomName) => `Scrub ${roomName} sink and faucet`,
                    description: 'Daily-use area prone to buildup - prevent bacteria growth'
                },
                {
                    type: 'stovetop',
                    name: (roomName) => `Wipe down ${roomName} stovetop and burners`,
                    description: 'Cooking surface prone to spills - prevent grease buildup'
                },
                {
                    type: 'microwave',
                    name: (roomName) => `Clean ${roomName} microwave interior`,
                    description: 'Food splatter zone - maintain hygiene and prevent odors'
                }
            ]
        };

        // State for keystone onboarding
        const KeystoneOnboardingState = {
            selectedKeystones: [],
            isInitializing: false
        };

        /**
         * Generate keystones for each room based on room type
         * @param {Array} rooms - User's room configurations
         * @returns {Array} - Array of keystone objects with task_type, name, description
         */
        function getApplicableKeystones(rooms) {
            const keystones = [];

            rooms.forEach(room => {
                const templates = KEYSTONE_FIXTURE_TEMPLATES[room.room_type];

                if (templates) {
                    // Generate a keystone for each fixture in this room
                    templates.forEach((template, index) => {
                        keystones.push({
                            task_type: `${template.type}_${room.id}`,
                            name: template.name(room.custom_name),
                            description: template.description,
                            room_id: room.id,
                            room_name: room.custom_name,
                            fixture_type: template.type
                        });
                    });
                }
            });

            return keystones;
        }

        /**
         * Render the keystone onboarding checklist
         * @param {Array} applicableKeystones - Array of keystone objects
         */
        function renderKeystoneOnboardingList(applicableKeystones) {
            const container = document.getElementById('keystoneOnboardingList');

            // If no applicable keystones, show a message
            if (applicableKeystones.length === 0) {
                container.innerHTML = `
                    <div class="no-keystones-message">
                        <p>No high-frequency hygiene points detected for your current room configuration.</p>
                        <p>You can add kitchens or bathrooms in Settings to enable keystone tasks.</p>
                    </div>
                `;
                KeystoneOnboardingState.selectedKeystones = [];
                return;
            }

            // Default: all applicable keystones selected
            KeystoneOnboardingState.selectedKeystones = applicableKeystones.map(k => ({...k, selected: true}));

            const html = applicableKeystones.map((keystone, index) => `
                <div class="keystone-onboarding-item selected" data-keystone-index="${index}" onclick="toggleKeystoneSelection(${index})">
                    <div class="keystone-checkbox-container">
                        <input type="checkbox"
                               class="keystone-checkbox"
                               id="keystone-${index}"
                               checked
                               onchange="event.stopPropagation(); toggleKeystoneSelection(${index})">
                    </div>
                    <label for="keystone-${index}" class="keystone-content" onclick="event.stopPropagation(); toggleKeystoneSelection(${index})">
                        <div class="keystone-name">${keystone.name}</div>
                        <div class="keystone-description">${keystone.description}</div>
                    </label>
                </div>
            `).join('');

            container.innerHTML = html;
        }

        /**
         * Toggle keystone selection
         * @param {number} index - Index of keystone in the list
         */
        function toggleKeystoneSelection(index) {
            const item = document.querySelector(`[data-keystone-index="${index}"]`);
            const checkbox = document.getElementById(`keystone-${index}`);

            if (!item || !checkbox) return;

            // Toggle checkbox
            checkbox.checked = !checkbox.checked;

            // Update visual state and selection
            const keystone = KeystoneOnboardingState.selectedKeystones[index];
            if (!keystone) return;

            if (checkbox.checked) {
                item.classList.add('selected');
                keystone.selected = true;
            } else {
                item.classList.remove('selected');
                keystone.selected = false;
            }
        }

        /**
         * Open keystone onboarding modal
         */
        async function openKeystoneOnboardingModal() {
            try {
                // Fetch user's rooms to determine applicable keystones
                const response = await RoomAPI.getUserRooms();
                const rooms = response.rooms || [];

                // Get applicable keystones based on user's room configuration
                const applicableKeystones = getApplicableKeystones(rooms);

                // Render the filtered list
                renderKeystoneOnboardingList(applicableKeystones);

                // Show the modal
                document.getElementById('keystoneOnboardingOverlay').style.display = 'flex';
            } catch (error) {
                console.error('Failed to load keystone onboarding:', error);
                showNotification('Failed to load keystone configuration. Please try again.', 'error');
            }
        }

        /**
         * Close keystone onboarding modal
         */
        function closeKeystoneOnboardingModal() {
            document.getElementById('keystoneOnboardingOverlay').style.display = 'none';
        }

        /**
         * Handle save keystones from onboarding
         */
        async function handleSaveKeystonesOnboarding() {
            const saveButton = document.getElementById('saveKeystonesOnboarding');
            const originalText = saveButton.innerHTML;

            try {
                saveButton.disabled = true;
                saveButton.innerHTML = 'Saving...';
                KeystoneOnboardingState.isInitializing = true;

                // Filter selected keystones only
                const selectedKeystones = KeystoneOnboardingState.selectedKeystones
                    .filter(k => k.selected !== false)
                    .map(k => ({
                        task_type: k.task_type,
                        custom_name: k.name
                    }));

                await KeystoneAPI.initializeKeystones(selectedKeystones);

                // Close modal
                closeKeystoneOnboardingModal();

                // Show success message and refresh
                showNotification('Keystone tasks configured successfully!', 'success');

                // Trigger rotation generation if user has rooms configured
                await loadDashboard();

            } catch (error) {
                console.error('Failed to initialize keystones:', error);
                showNotification(error.message || 'Failed to configure keystone tasks. Please try again.', 'error');
                saveButton.disabled = false;
                saveButton.innerHTML = originalText;
            } finally {
                KeystoneOnboardingState.isInitializing = false;
            }
        }

        /**
         * Handle skip keystones onboarding
         */
        async function handleSkipKeystonesOnboarding() {
            try {
                // Initialize with no active keystones (all disabled)
                await KeystoneAPI.initializeKeystones([]);
                closeKeystoneOnboardingModal();
                showNotification('Keystone tasks skipped. You can enable them later in Settings.', 'info');
                await loadDashboard();
            } catch (error) {
                console.error('Failed to skip keystones:', error);
                // If initialization fails, just close the modal
                closeKeystoneOnboardingModal();
            }
        }

        /**
         * Check if user needs keystone onboarding and show modal if needed
         */
        async function checkAndShowKeystoneOnboarding() {
            try {
                const response = await KeystoneAPI.getUserKeystones();

                // If user has no keystones, show onboarding
                if (!response.has_keystones || response.keystone_tasks.length === 0) {
                    await openKeystoneOnboardingModal();
                    return true;
                }

                return false;
            } catch (error) {
                console.error('Failed to check keystone status:', error);
                return false;
            }
        }

        // ============================================
        // SETTINGS MODAL FUNCTIONS
        // ============================================

        const SettingsState = {
            rooms: [],
            keystones: [],
            hasUnsavedChanges: false,
            isPendingCycleCompletion: false
        };

        /**
         * Open settings modal and load current configuration
         */
        async function openSettingsModal() {
            document.getElementById('settingsOverlay').style.display = 'flex';

            // Reset to rooms tab
            switchTab('rooms');

            // Load all settings data
            await loadSettingsData();
        }

        /**
         * Close settings modal
         */
        function closeSettingsModal() {
            if (SettingsState.hasUnsavedChanges) {
                if (!confirm('You have unsaved changes. Close without saving?')) {
                    return;
                }
            }

            document.getElementById('settingsOverlay').style.display = 'none';
            SettingsState.hasUnsavedChanges = false;
            hideAddRoomForm();
        }

        /**
         * Switch between tabs in settings modal
         */
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(`${tabName}Tab`).classList.add('active');

            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

            // Load data for specific tabs
            if (tabName === 'preview') {
                loadTaskPreview();
            } else if (tabName === 'account') {
                loadAccountInfo();
            }
        }

        /**
         * Load all settings data from API
         */
        async function loadSettingsData() {
            try {
                // Load rooms
                const roomsResponse = await RoomAPI.getUserRooms();
                SettingsState.rooms = roomsResponse.rooms || [];
                renderSettingsRoomsList();

                // Load keystones
                const keystonesResponse = await KeystoneAPI.getUserKeystones();
                SettingsState.keystones = keystonesResponse.keystone_tasks || [];
                renderKeystonesList();

            } catch (error) {
                console.error('Failed to load settings data:', error);
                showNotification('Failed to load settings', 'error', 3000);
            }
        }

        /**
         * Render rooms list in settings
         */
        function renderSettingsRoomsList() {
            const container = document.getElementById('settingsRoomsList');

            if (SettingsState.rooms.length === 0) {
                container.innerHTML = '<p class="empty-state">No rooms configured yet. Add your first room below!</p>';
                return;
            }

            container.innerHTML = SettingsState.rooms.map((room, index) => `
                <div class="settings-room-card" data-room-id="${room.id}">
                    <div class="settings-room-header">
                        <div class="room-reorder-controls">
                            <button class="reorder-btn" onclick="moveRoomUp('${room.id}')" ${index === 0 ? 'disabled' : ''}>â–²</button>
                            <button class="reorder-btn" onclick="moveRoomDown('${room.id}')" ${index === SettingsState.rooms.length - 1 ? 'disabled' : ''}>â–¼</button>
                        </div>
                        <div class="room-icon">${getRoomIcon(room.room_type)}</div>
                        <div class="room-name">${room.custom_name}</div>
                        <div class="room-type-badge">${formatRoomType(room.room_type)}</div>
                    </div>
                    <div class="room-details">
                        <span class="glass-indicator">${room.has_glass ? 'ðŸªŸ Has glass' : 'No glass'}</span>
                    </div>
                    <div class="room-actions">
                        <button class="edit-room-btn" onclick="editRoom('${room.id}')">Edit</button>
                        <button class="delete-room-btn" onclick="deleteRoom('${room.id}')">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        /**
         * Render keystones list in settings
         */
        function renderKeystonesList() {
            const container = document.getElementById('keystonesList');

            if (SettingsState.keystones.length === 0) {
                container.innerHTML = '<p class="empty-state">No keystone tasks available.</p>';
                return;
            }

            // Debug: log keystone data to help identify any issues
            console.log('Rendering keystones:', SettingsState.keystones);

            container.innerHTML = SettingsState.keystones.map(keystone => {
                // Debug: warn if task_type looks suspicious
                if (keystone.task_type && keystone.task_type.length > 50) {
                    console.warn('Suspicious task_type detected:', {
                        id: keystone.id,
                        task_type: keystone.task_type
                    });
                }

                return `
                <div class="keystone-item" data-keystone-id="${keystone.id}">
                    <div class="keystone-toggle">
                        <label class="switch">
                            <input type="checkbox"
                                   class="keystone-active-toggle"
                                   onchange="toggleKeystone('${keystone.id}', this.checked)"
                                   ${keystone.is_active ? 'checked' : ''}>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="keystone-info">
                        <div class="keystone-default-name">${getKeystoneDefaultName(keystone.task_type)}</div>
                        <input type="text"
                               class="keystone-custom-name"
                               placeholder="Custom name (optional)"
                               value="${keystone.custom_name || ''}"
                               onchange="updateKeystoneCustomName('${keystone.id}', this.value)">
                    </div>
                </div>
            `}).join('');
        }

        /**
         * Load task preview
         */
        async function loadTaskPreview() {
            const container = document.getElementById('taskPreviewList');

            // Show loading indicator
            container.innerHTML = `
                <div class="loading-spinner">
                    <div class="spinner"></div>
                    <p>Loading task preview...</p>
                </div>
            `;

            try {
                const response = await TaskAPI.previewTasks(20);
                renderTaskPreview(response.preview || [], response.current_position || 0, response.total_tasks || 0);
            } catch (error) {
                console.error('Failed to load task preview:', error);
                let errorMessage = 'Failed to load task preview.';

                // Provide more specific error messages
                if (error.status === 401) {
                    errorMessage = 'Please log in to view your task preview.';
                } else if (error.status === 500) {
                    errorMessage = 'Server error. Please try again later.';
                } else if (error.message && error.message.includes('Network')) {
                    errorMessage = 'Network error. Please check your connection.';
                }

                container.innerHTML = `<p class="empty-state">${errorMessage}</p>`;

                // Reset progress indicators on error
                document.getElementById('currentPositionPreview').textContent = '-';
                document.getElementById('totalTasksPreview').textContent = '-';
            }
        }

        /**
         * Render task preview
         */
        function renderTaskPreview(tasks, currentPosition, totalTasks) {
            const container = document.getElementById('taskPreviewList');

            if (!tasks || tasks.length === 0) {
                container.innerHTML = '<p class="empty-state">No tasks in rotation yet. Configure rooms to generate tasks.</p>';
                // Reset progress indicators
                document.getElementById('currentPositionPreview').textContent = '0';
                document.getElementById('totalTasksPreview').textContent = '0';
                return;
            }

            container.innerHTML = tasks.map(task => `
                <div class="preview-task-item ${task.position === currentPosition ? 'current' : ''}" data-position="${task.position}">
                    <div class="task-number">${task.position}</div>
                    <div class="task-description">${task.description || 'Task description unavailable'}</div>
                    <div class="task-meta">
                        ${task.task_type === 'pillar'
                            ? `<span class="badge pillar">${task.room ? task.room.name : 'Room'} - ${task.pillar_type}</span>`
                            : `<span class="badge keystone">Keystone</span>`
                        }
                    </div>
                </div>
            `).join('');

            document.getElementById('currentPositionPreview').textContent = currentPosition || 0;
            document.getElementById('totalTasksPreview').textContent = totalTasks || 0;
        }

        /**
         * Load account info
         */
        function loadAccountInfo() {
            if (AppState.user.isAuthenticated && AppState.user.profile) {
                document.getElementById('accountEmail').textContent = AppState.user.profile.email || '-';
                document.getElementById('accountCreated').textContent = AppState.user.profile.createdAt
                    ? new Date(AppState.user.profile.createdAt).toLocaleDateString()
                    : '-';
                document.getElementById('accountCompletions').textContent = AppState.engagement.totalCompletions || 0;
            }
        }

        /**
         * Open change password modal
         */
        function openChangePasswordModal() {
            document.getElementById('changePasswordOverlay').style.display = 'flex';
            document.getElementById('changePasswordForm').reset();
            document.getElementById('changePasswordError').textContent = '';
            document.getElementById('changePasswordError').classList.remove('show');
            document.getElementById('changePasswordSuccess').style.display = 'none';
        }

        /**
         * Close change password modal
         */
        function closeChangePasswordModal() {
            document.getElementById('changePasswordOverlay').style.display = 'none';
            document.getElementById('changePasswordForm').reset();
        }

        /**
         * Handle change password form submission
         */
        async function handleChangePassword(event) {
            event.preventDefault();

            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;
            const confirmNewPassword = document.getElementById('confirmNewPassword').value;

            const errorEl = document.getElementById('changePasswordError');
            const successEl = document.getElementById('changePasswordSuccess');
            const submitBtn = document.getElementById('changePasswordSubmitBtn');

            // Clear previous messages
            errorEl.textContent = '';
            errorEl.classList.remove('show');
            successEl.style.display = 'none';

            // Validate passwords match
            if (newPassword !== confirmNewPassword) {
                errorEl.textContent = 'New passwords do not match';
                errorEl.classList.add('show');
                return;
            }

            // Disable submit button and show loading
            submitBtn.disabled = true;
            submitBtn.querySelector('.button-text').style.display = 'none';
            submitBtn.querySelector('.button-loading').style.display = 'inline';

            try {
                const response = await fetch(`${API_BASE_URL}/user/change-password`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        currentPassword,
                        newPassword
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    successEl.textContent = data.message || 'Password changed successfully!';
                    successEl.style.display = 'block';
                    document.getElementById('changePasswordForm').reset();

                    // Close modal after 2 seconds
                    setTimeout(() => {
                        closeChangePasswordModal();
                    }, 2000);
                } else {
                    let errorMessage = data.message || 'Failed to change password';

                    // Show validation errors if available
                    if (data.errors && Array.isArray(data.errors)) {
                        errorMessage += ': ' + data.errors.join(', ');
                    }

                    errorEl.textContent = errorMessage;
                    errorEl.classList.add('show');
                }
            } catch (error) {
                console.error('Password change error:', error);
                errorEl.textContent = 'Network error. Please try again.';
                errorEl.classList.add('show');
            } finally {
                // Re-enable submit button
                submitBtn.disabled = false;
                submitBtn.querySelector('.button-text').style.display = 'inline';
                submitBtn.querySelector('.button-loading').style.display = 'none';
            }
        }

        /**
         * Open delete account modal
         */
        function openDeleteAccountModal() {
            document.getElementById('deleteAccountOverlay').style.display = 'flex';
            document.getElementById('deleteAccountForm').reset();
            document.getElementById('deleteAccountError').textContent = '';
            document.getElementById('deleteAccountError').classList.remove('show');
        }

        /**
         * Close delete account modal
         */
        function closeDeleteAccountModal() {
            document.getElementById('deleteAccountOverlay').style.display = 'none';
            document.getElementById('deleteAccountForm').reset();
        }

        /**
         * Handle delete account form submission
         */
        async function handleDeleteAccount(event) {
            event.preventDefault();

            const email = document.getElementById('deleteAccountEmail').value;
            const confirmation = document.getElementById('deleteAccountConfirmation').value;

            const errorEl = document.getElementById('deleteAccountError');
            const submitBtn = document.getElementById('deleteAccountSubmitBtn');

            // Clear previous errors
            errorEl.textContent = '';
            errorEl.classList.remove('show');

            // Validate confirmation text
            if (confirmation !== 'DELETE MY ACCOUNT') {
                errorEl.textContent = 'Please type "DELETE MY ACCOUNT" exactly to confirm';
                errorEl.classList.add('show');
                return;
            }

            // Double-check with user
            if (!confirm('Are you absolutely sure? This action cannot be undone!')) {
                return;
            }

            // Disable submit button and show loading
            submitBtn.disabled = true;
            submitBtn.querySelector('.button-text').style.display = 'none';
            submitBtn.querySelector('.button-loading').style.display = 'inline';

            try {
                const response = await fetch(`${API_BASE_URL}/user/account`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        email,
                        confirmation
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    // Account deleted successfully
                    alert('Your account has been deleted successfully.');

                    // Close modal and log out
                    closeDeleteAccountModal();
                    handleLogout();
                } else {
                    errorEl.textContent = data.message || 'Failed to delete account';
                    errorEl.classList.add('show');
                }
            } catch (error) {
                console.error('Account deletion error:', error);
                errorEl.textContent = 'Network error. Please try again.';
                errorEl.classList.add('show');
            } finally {
                // Re-enable submit button
                submitBtn.disabled = false;
                submitBtn.querySelector('.button-text').style.display = 'inline';
                submitBtn.querySelector('.button-loading').style.display = 'none';
            }
        }

        /**
         * Show add room form in settings
         */
        function showAddRoomForm() {
            document.getElementById('addRoomInSettings').style.display = 'block';
            document.getElementById('addRoomSettingsBtn').style.display = 'none';
        }

        /**
         * Hide add room form in settings
         */
        function hideAddRoomForm() {
            document.getElementById('addRoomInSettings').style.display = 'none';
            document.getElementById('addRoomSettingsBtn').style.display = 'block';
            document.getElementById('roomFormSettings').reset();
        }

        /**
         * Handle add room form submission in settings
         */
        async function handleAddRoomInSettings(event) {
            event.preventDefault();

            const roomType = document.getElementById('roomTypeSettings').value;
            let customName = document.getElementById('customRoomNameSettings').value.trim();
            const hasGlass = document.getElementById('hasGlassSettings').checked;
            const autoAddKeystones = document.getElementById('autoAddKeystonesSettings').checked;

            // If custom name is empty, generate a unique name based on room type
            if (!customName) {
                customName = generateUniqueRoomName(roomType, SettingsState.rooms);
            }

            try {
                const response = await RoomAPI.createRoom({ roomType, customName, hasGlass });

                if (response.success && response.room) {
                    const newRoom = response.room;
                    SettingsState.rooms.push(newRoom);

                    let keystonesAdded = 0;

                    // Add keystones if user opted in
                    if (autoAddKeystones) {
                        try {
                            const applicableKeystones = getApplicableKeystones([newRoom]);

                            if (applicableKeystones.length > 0) {
                                await KeystoneAPI.addKeystonesForRoom(applicableKeystones);
                                keystonesAdded = applicableKeystones.length;
                                console.log(`Added ${keystonesAdded} keystone(s) for ${customName}`);

                                // Refresh keystones list in settings
                                const keystonesResponse = await KeystoneAPI.getUserKeystones();
                                SettingsState.keystones = keystonesResponse.keystone_tasks || [];
                                renderKeystonesList();
                            }
                        } catch (keystoneError) {
                            // Don't fail the whole operation if keystone creation fails
                            console.error('Failed to add keystones for room:', keystoneError);
                        }
                    }

                    renderSettingsRoomsList();
                    hideAddRoomForm();
                    SettingsState.hasUnsavedChanges = false; // Room already saved via API

                    // Show notification with keystone count
                    const message = keystonesAdded > 0
                        ? `Room added successfully! ${keystonesAdded} keystone task(s) added.`
                        : 'Room added successfully!';
                    showNotification(message, 'success', 3000);
                }
            } catch (error) {
                console.error('Failed to add room:', error);
                showNotification('Failed to add room. Please try again.', 'error', 3000);
            }
        }

        /**
         * Move room up in order
         */
        function moveRoomUp(roomId) {
            const index = SettingsState.rooms.findIndex(r => r.id === roomId);
            if (index > 0) {
                [SettingsState.rooms[index], SettingsState.rooms[index - 1]] =
                [SettingsState.rooms[index - 1], SettingsState.rooms[index]];

                SettingsState.rooms.forEach((room, i) => {
                    room.sort_order = i + 1;
                });

                renderSettingsRoomsList();
                SettingsState.hasUnsavedChanges = true;
            }
        }

        /**
         * Move room down in order
         */
        function moveRoomDown(roomId) {
            const index = SettingsState.rooms.findIndex(r => r.id === roomId);
            if (index < SettingsState.rooms.length - 1) {
                [SettingsState.rooms[index], SettingsState.rooms[index + 1]] =
                [SettingsState.rooms[index + 1], SettingsState.rooms[index]];

                SettingsState.rooms.forEach((room, i) => {
                    room.sort_order = i + 1;
                });

                renderSettingsRoomsList();
                SettingsState.hasUnsavedChanges = true;
            }
        }

        /**
         * Delete a room
         */
        async function deleteRoom(roomId) {
            if (!confirm('Delete this room? This will take effect after completing the current rotation.')) {
                return;
            }

            try {
                const response = await RoomAPI.deleteRoom(roomId);

                if (response.success) {
                    SettingsState.rooms = SettingsState.rooms.filter(r => r.id !== roomId);
                    renderSettingsRoomsList();
                    SettingsState.isPendingCycleCompletion = true;
                    document.getElementById('pendingChangesNotice').style.display = 'block';
                    showNotification('Room will be removed after current cycle', 'info', 3000);
                }
            } catch (error) {
                console.error('Failed to delete room:', error);
                showNotification('Failed to delete room', 'error', 3000);
            }
        }

        /**
         * Edit a room (simplified - just shows form with values)
         */
        function editRoom(roomId) {
            // For MVP, we'll use a simple prompt. Full implementation would use a modal
            showNotification('Edit functionality: Use delete and re-add for now', 'info', 3000);
        }

        /**
         * Toggle keystone active state
         */
        function toggleKeystone(keystoneId, isActive) {
            const keystone = SettingsState.keystones.find(k => k.id === keystoneId);
            if (keystone) {
                keystone.is_active = isActive;
                SettingsState.hasUnsavedChanges = true;
            }
        }

        /**
         * Update keystone custom name
         */
        function updateKeystoneCustomName(keystoneId, customName) {
            const keystone = SettingsState.keystones.find(k => k.id === keystoneId);
            if (keystone) {
                keystone.custom_name = customName || null;
                SettingsState.hasUnsavedChanges = true;
            }
        }

        /**
         * Save all settings changes
         */
        async function handleSaveSettings() {
            if (!SettingsState.hasUnsavedChanges) {
                closeSettingsModal();
                return;
            }

            try {
                // Save room order if changed
                if (SettingsState.hasUnsavedChanges) {
                    const roomIds = SettingsState.rooms.map(r => r.id);
                    await RoomAPI.reorderRooms(roomIds);
                }

                // Save keystone changes
                for (const keystone of SettingsState.keystones) {
                    if (keystone.is_active !== undefined || keystone.custom_name !== undefined) {
                        await KeystoneAPI.updateKeystone(keystone.id, {
                            isActive: keystone.is_active,
                            customName: keystone.custom_name
                        });
                    }
                }

                SettingsState.hasUnsavedChanges = false;
                SettingsState.isPendingCycleCompletion = true;
                document.getElementById('pendingChangesNotice').style.display = 'block';

                showNotification('Settings saved! Changes will apply after completing current cycle.', 'success', 3000);
            } catch (error) {
                console.error('Failed to save settings:', error);
                showNotification('Failed to save settings', 'error', 3000);
            }
        }

        /**
         * Get room icon emoji
         */
        function getRoomIcon(roomType) {
            const icons = {
                living_room: 'ðŸ›‹ï¸',
                bedroom: 'ðŸ›ï¸',
                kitchen: 'ðŸ³',
                bathroom: 'ðŸš¿',
                office: 'ðŸ’¼',
                dining_room: 'ðŸ½ï¸',
                laundry: 'ðŸ§º',
                garage: 'ðŸš—'
            };
            return icons[roomType] || 'ðŸ ';
        }

        /**
         * Format room type for display
         */
        function formatRoomType(roomType) {
            return roomType.split('_').map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        /**
         * Get keystone default name
         */
        function getKeystoneDefaultName(taskType) {
            // Handle null/undefined
            if (!taskType) {
                return 'Unknown Task';
            }

            const names = {
                master_toilet: 'Scrub and disinfect master toilet',
                guest_toilet: 'Scrub and disinfect guest/hall toilet',
                kitchen_sink: 'Scrub kitchen sink and faucet',
                master_bath_sink: 'Clean master bathroom sink',
                guest_bath_sink: 'Clean guest bathroom sink',
                stovetop: 'Wipe down stovetop and burners',
                shower_tub: 'Scrub shower/tub',
                microwave: 'Clean microwave interior'
            };

            // If exact match found, return it
            if (names[taskType]) {
                return names[taskType];
            }

            // If taskType looks like an ID (contains underscore followed by long alphanumeric),
            // try to extract the actual task type
            const idPattern = /^([a-z_]+)_[a-z0-9]{20,}$/i;
            const match = taskType.match(idPattern);
            if (match) {
                const extractedType = match[1];
                console.warn(`Keystone task_type appears to be an ID. Extracted: ${extractedType} from ${taskType}`);
                // Try to find a match with the extracted type
                if (names[extractedType]) {
                    return names[extractedType];
                }
                // Return a friendly version of the extracted type
                return extractedType.split('_').map(word =>
                    word.charAt(0).toUpperCase() + word.slice(1)
                ).join(' ');
            }

            // Fallback: format the task type nicely
            return taskType.split('_').map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        /**
         * Handle user registration
         * @param {Event} event - Form submit event
         */
        async function handleRegister(event) {
            event.preventDefault();

            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;

            // Clear previous errors
            document.getElementById('registerError').classList.remove('show');

            // Client-side validation
            if (!email || !password || !confirmPassword) {
                showAuthError('register', 'All fields are required');
                return;
            }

            if (password !== confirmPassword) {
                showAuthError('register', 'Passwords do not match');
                return;
            }

            if (password.length < 8) {
                showAuthError('register', 'Password must be at least 8 characters');
                return;
            }

            // Show loading state
            const submitButton = document.getElementById('registerSubmitButton');
            submitButton.disabled = true;
            submitButton.classList.add('loading');

            try {
                // Call register API
                const response = await AuthAPI.register(email, password, confirmPassword);

                // Update state with user data
                AppState.user.isAuthenticated = true;
                AppState.user.profile = {
                    id: response.user.id,
                    email: response.user.email,
                    email_verified: response.user.email_verified || false,
                    createdAt: response.user.createdAt,
                    preferences: response.user.preferences || {}
                };

                // Migrate any anonymous data
                await migrateAnonymousData();

                // Sync with server to get latest data
                await syncWithServer();

                // Start background sync for authenticated user
                startBackgroundSync();

                // Start connectivity monitoring
                startConnectivityMonitoring();

                // Save state
                saveState();

                // Update UI
                updateAuthUI();
                updateConnectionStatus();
                updateSyncQueueIndicator();

                // Show verification banner if email not verified
                checkAndShowVerificationBanner();

                // Hide modal
                hideAuthModal();

                // Show success notification with verification reminder
                showNotification('Account created! Please check your email to verify your account.', 'success', 5000);
                console.log('Registration successful! Verification email sent.');

                // Show onboarding modal to configure rooms
                setTimeout(() => {
                    showOnboardingModal();
                }, 500);
            } catch (error) {
                console.error('Registration error:', error);
                showAuthError('register', error.message || 'Registration failed. Please try again.');
            } finally {
                // Reset button state
                submitButton.disabled = false;
                submitButton.classList.remove('loading');
            }
        }

        /**
         * Handle user login
         * @param {Event} event - Form submit event
         */
        async function handleLogin(event) {
            event.preventDefault();

            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            // Clear previous errors
            document.getElementById('loginError').classList.remove('show');

            // Client-side validation
            if (!email || !password) {
                showAuthError('login', 'Email and password are required');
                return;
            }

            // Show loading state
            const submitButton = document.getElementById('loginSubmitButton');
            submitButton.disabled = true;
            submitButton.classList.add('loading');

            try {
                // Call login API
                const response = await AuthAPI.login(email, password);

                // Update state with user data
                AppState.user.isAuthenticated = true;
                AppState.user.profile = {
                    id: response.user.id,
                    email: response.user.email,
                    email_verified: response.user.email_verified || false,
                    createdAt: response.user.createdAt,
                    preferences: response.user.preferences || {}
                };

                // Migrate any anonymous data
                await migrateAnonymousData();

                // Sync with server to get latest data
                await syncWithServer();

                // Load dashboard to refresh task display
                await loadDashboard();

                // Start background sync for authenticated user
                startBackgroundSync();

                // Start connectivity monitoring
                startConnectivityMonitoring();

                // Save state
                saveState();

                // Update UI
                updateAuthUI();
                updateConnectionStatus();
                updateSyncQueueIndicator();

                // Check verification status and show banner if needed
                checkAndShowVerificationBanner();

                // Phase 7: Check migration status and show banner if needed
                await checkMigrationStatus();

                // Check if user needs keystone onboarding
                const needsKeystoneOnboarding = await checkAndShowKeystoneOnboarding();

                // Hide modal
                hideAuthModal();

                // Show success notification (unless keystone onboarding is showing)
                if (!needsKeystoneOnboarding) {
                    showNotification('Welcome back!', 'success', 3000);
                }
                console.log('Login successful!');
            } catch (error) {
                console.error('Login error:', error);

                // Provide helpful error message
                let errorMessage = error.message || 'Login failed. Please check your credentials.';

                // If it's an authentication error, add helpful reminder
                if (errorMessage.includes('Invalid') || errorMessage.includes('password') || errorMessage.includes('credentials')) {
                    errorMessage = 'Invalid email or password. Don\'t have an account? Click "Create one" below.';
                }

                showAuthError('login', errorMessage);
            } finally {
                // Reset button state
                submitButton.disabled = false;
                submitButton.classList.remove('loading');
            }
        }

        /**
         * Handle user logout
         */
        async function handleLogout() {
            try {
                // Call logout API
                await AuthAPI.logout();
            } catch (error) {
                console.error('Logout error:', error);
                // Continue with local logout even if API call fails
            }

            // Stop background sync and connectivity monitoring
            stopBackgroundSync();
            stopConnectivityMonitoring();

            // Clear authenticated state
            AppState.user.isAuthenticated = false;
            AppState.user.profile = null;
            AppState.sync.status = 'idle';
            AppState.sync.lastSyncTime = null;
            AppState.sync.offlineQueue = [];

            // Clear authenticated data from localStorage
            clearState();

            // Reset to anonymous state
            AppState.streak = {
                current: 0,
                lastCompletedDate: null,
                bestStreak: 0,
                history: []
            };
            AppState.engagement = {
                totalCompletions: 0,
                consecutiveDays: 0,
                firstVisit: null,
                lastVisit: null,
                visitCount: 0,
                hasSeenAuthPrompt: false,
                dismissedAuthPromptCount: 0
            };

            // Update UI
            updateAuthUI();
            updateConnectionStatus();
            updateSyncQueueIndicator();
            updateDisplay();

            // Show notification
            showNotification('Logged out successfully', 'info', 3000);

            console.log('Logged out successfully');
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        // Load state on page load
        loadState();

        // Validate session if user appears to be authenticated
        if (AppState.user.isAuthenticated) {
            // Validate the session with the server
            // This will automatically handle token refresh if needed
            validateSession().then(() => {
                // After validation, start background processes
                startBackgroundSync();
                startConnectivityMonitoring();
                // Check email verification status and show banner if needed
                checkAndShowVerificationBanner();
                // Phase 7: Check migration status on app load
                checkMigrationStatus();
            }).catch(error => {
                console.error('Session validation error during init:', error);
                // Error already handled by validateSession/handleSessionExpired
            });
        }

        // Update UI to match authentication state
        updateAuthUI();

        // Initialize connection status display
        updateConnectionStatus();

        // Initialize sync queue indicator
        updateSyncQueueIndicator();

        // Network status monitoring with enhanced offline handling
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        // Event listeners - Core functionality
        document.getElementById('doneButton').addEventListener('click', completeTask);

        // Event listeners - Authentication
        document.getElementById('loginButton').addEventListener('click', () => showAuthModal('login'));
        document.getElementById('logoutButton').addEventListener('click', handleLogout);

        // Form submissions
        document.getElementById('loginFormElement').addEventListener('submit', handleLogin);
        document.getElementById('registerFormElement').addEventListener('submit', handleRegister);

        // Modal controls
        document.getElementById('closeLoginModal').addEventListener('click', hideAuthModal);
        document.getElementById('closeRegisterModal').addEventListener('click', hideAuthModal);

        // Switch between login and register
        document.getElementById('showRegisterLink').addEventListener('click', (e) => {
            e.preventDefault();
            showAuthModal('register');
        });
        document.getElementById('showLoginLink').addEventListener('click', (e) => {
            e.preventDefault();
            showAuthModal('login');
        });

        // Close modal when clicking overlay
        document.getElementById('authOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'authOverlay') {
                hideAuthModal();
            }
        });

        // Event listeners - Email Verification
        document.getElementById('resendVerificationBtn').addEventListener('click', handleResendVerification);
        document.getElementById('closeVerificationBanner').addEventListener('click', hideVerificationBanner);

        // Event listeners - Onboarding
        document.getElementById('roomForm').addEventListener('submit', handleRoomFormSubmit);
        document.getElementById('finishOnboarding').addEventListener('click', handleFinishOnboarding);
        document.getElementById('skipOnboarding').addEventListener('click', handleSkipOnboarding);

        // Event listeners - Keystone Onboarding
        document.getElementById('saveKeystonesOnboarding').addEventListener('click', handleSaveKeystonesOnboarding);
        document.getElementById('skipKeystonesOnboarding').addEventListener('click', handleSkipKeystonesOnboarding);

        // Close onboarding when clicking overlay
        document.getElementById('onboardingOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'onboardingOverlay') {
                // Don't allow closing by clicking overlay during onboarding
                // User must complete or skip
            }
        });

        // Event listeners - Settings Modal
        document.getElementById('settingsButton').addEventListener('click', openSettingsModal);
        document.getElementById('closeSettingsModal').addEventListener('click', closeSettingsModal);
        document.getElementById('cancelSettingsBtn').addEventListener('click', closeSettingsModal);
        document.getElementById('saveSettingsBtn').addEventListener('click', handleSaveSettings);

        // Settings - Room Management
        document.getElementById('addRoomSettingsBtn').addEventListener('click', showAddRoomForm);
        document.getElementById('cancelAddRoomSettings').addEventListener('click', hideAddRoomForm);
        document.getElementById('roomFormSettings').addEventListener('submit', handleAddRoomInSettings);

        // Settings - Tab Switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tabName = e.target.dataset.tab;
                switchTab(tabName);
            });
        });

        // Close settings when clicking overlay
        document.getElementById('settingsOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'settingsOverlay') {
                closeSettingsModal();
            }
        });

        // Event listeners - Change Password Modal
        document.getElementById('changePasswordBtn').addEventListener('click', openChangePasswordModal);
        document.getElementById('closeChangePasswordModal').addEventListener('click', closeChangePasswordModal);
        document.getElementById('cancelChangePasswordBtn').addEventListener('click', closeChangePasswordModal);
        document.getElementById('changePasswordForm').addEventListener('submit', handleChangePassword);

        // Close change password modal when clicking overlay
        document.getElementById('changePasswordOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'changePasswordOverlay') {
                closeChangePasswordModal();
            }
        });

        // Event listeners - Delete Account Modal
        document.getElementById('deleteAccountBtn').addEventListener('click', openDeleteAccountModal);
        document.getElementById('closeDeleteAccountModal').addEventListener('click', closeDeleteAccountModal);
        document.getElementById('cancelDeleteAccountBtn').addEventListener('click', closeDeleteAccountModal);
        document.getElementById('deleteAccountForm').addEventListener('submit', handleDeleteAccount);

        // Close delete account modal when clicking overlay
        document.getElementById('deleteAccountOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'deleteAccountOverlay') {
                closeDeleteAccountModal();
            }
        });

        // Handle email verification from URL token (if present)
        handleEmailVerification();

        // Initial display update
        updateDisplay();

        // Handle URL actions from welcome.html
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const action = urlParams.get('action');
            if (action === 'login') {
                showAuthModal('login');
            } else if (action === 'register') {
                showAuthModal('register');
            }
        });
    </script>
</body>
</html>