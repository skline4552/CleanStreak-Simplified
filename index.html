<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Clean</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px 30px;
            max-width: 400px;
            width: 100%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        /* User Header Styles */
        .user-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f1f3f5;
        }

        .user-status {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            background: #e9ecef;
            color: #495057;
            font-size: 0.85rem;
            font-weight: 600;
            border-radius: 12px;
        }

        .status-badge.authenticated {
            background: #d4edda;
            color: #155724;
        }

        .user-email {
            font-size: 0.8rem;
            color: #6c757d;
            font-weight: 500;
        }

        .user-actions {
            display: flex;
            gap: 8px;
        }

        .header-button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .header-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .header-button.secondary {
            background: #6c757d;
        }

        .header-button.secondary:hover {
            background: #5a6268;
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2rem;
            font-weight: 700;
        }

        .task-card {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 30px 20px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }

        .task-text {
            font-size: 1.2rem;
            color: #495057;
            font-weight: 500;
            line-height: 1.4;
        }

        /* Task Progress Styles */
        #taskProgress {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #dee2e6;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .progress-text {
            font-size: 0.85rem;
            color: #6c757d;
            text-align: center;
            margin: 0;
        }

        /* Task Context Badge Styles */
        #taskContext {
            margin-top: 15px;
        }

        .badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .badge.pillar {
            background: #e3f2fd;
            color: #1976d2;
        }

        .badge.keystone {
            background: #fff3e0;
            color: #f57c00;
        }

        /* Legacy Prompt Styles */
        #legacyPrompt {
            margin-top: 15px;
        }

        .info-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 12px 15px;
            font-size: 0.9rem;
            color: #856404;
            line-height: 1.5;
            margin: 0;
        }

        .info-box strong {
            color: #533f03;
        }

        .info-box a {
            color: #0056b3;
            text-decoration: underline;
            font-weight: 600;
        }

        .info-box a:hover {
            color: #003d82;
        }

        /* Migration Banner Styles (Phase 7) */
        #migrationBanner {
            margin-bottom: 20px;
        }

        .banner {
            position: relative;
            border-radius: 8px;
            padding: 12px 40px 12px 15px;
            font-size: 0.9rem;
            line-height: 1.5;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .banner.info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .banner.info strong {
            color: #062c33;
        }

        .banner.info a {
            color: #0056b3;
            text-decoration: underline;
            font-weight: 600;
        }

        .banner.info a:hover {
            color: #003d82;
        }

        .banner-close {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1.5rem;
            line-height: 1;
            color: #0c5460;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .banner-close:hover {
            color: #062c33;
            transform: translateY(-50%) scale(1.1);
        }

        .streak-counter {
            margin-bottom: 30px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 10px;
            border: 2px solid #28a745;
        }

        .streak-text {
            color: #28a745;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .done-button {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 20px 50px;
            font-size: 1.3rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
            width: 100%;
            max-width: 200px;
        }

        .done-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }

        .done-button:active {
            transform: translateY(0);
        }

        .done-button.completed {
            background: #6c757d;
            cursor: not-allowed;
        }

        .completed-message {
            color: #6c757d;
            font-size: 1.1rem;
            margin-top: 15px;
            display: none;
        }

        .completion-animation {
            animation: pulse 0.6s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @media (max-width: 480px) {
            .container {
                padding: 30px 20px;
            }

            h1 {
                font-size: 1.7rem;
            }

            .task-text {
                font-size: 1.1rem;
            }

            .user-header {
                flex-direction: column;
                gap: 12px;
                align-items: stretch;
            }

            .user-status {
                align-items: center;
            }

            .user-actions {
                justify-content: center;
            }

            .header-button {
                flex: 1;
            }
        }

        /* Authentication Modal Styles */
        #authOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #authModal {
            background: white;
            border-radius: 20px;
            max-width: 420px;
            width: 100%;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.3s ease;
            position: relative;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .auth-form {
            padding: 40px 35px;
        }

        .auth-form h2 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
        }

        .auth-subtitle {
            color: #6c757d;
            font-size: 0.95rem;
            text-align: center;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }

        .form-group label {
            display: block;
            color: #495057;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .form-group input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-group input::placeholder {
            color: #adb5bd;
        }

        .form-hint {
            display: block;
            color: #6c757d;
            font-size: 0.8rem;
            margin-top: 6px;
        }

        .form-error {
            background: #fff5f5;
            color: #e53e3e;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 20px;
            display: none;
            border: 1px solid #feb2b2;
        }

        .form-error.show {
            display: block;
        }

        .auth-button {
            width: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 16px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .auth-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .auth-button:active:not(:disabled) {
            transform: translateY(0);
        }

        .auth-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .button-loading {
            display: none;
        }

        .auth-button.loading .button-text {
            display: none;
        }

        .auth-button.loading .button-loading {
            display: inline;
        }

        .auth-footer {
            text-align: center;
            margin-top: 25px;
            color: #6c757d;
            font-size: 0.95rem;
        }

        .auth-footer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .auth-footer a:hover {
            text-decoration: underline;
        }

        .close-modal {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            font-size: 2rem;
            color: #adb5bd;
            cursor: pointer;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-modal:hover {
            background: #f8f9fa;
            color: #495057;
        }

        @media (max-width: 480px) {
            .auth-form {
                padding: 35px 25px;
            }

            .auth-form h2 {
                font-size: 1.6rem;
            }

            #authOverlay {
                padding: 15px;
            }
        }

        /* Onboarding Modal Styles */
        #onboardingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        #onboardingModal {
            background: white;
            border-radius: 20px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.3s ease;
            padding: 40px;
        }

        #onboardingModal h2 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
        }

        .onboarding-subtitle {
            color: #6c757d;
            font-size: 0.95rem;
            text-align: center;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #roomConfigSection {
            margin-bottom: 30px;
        }

        #configuredRoomsList h3,
        #addRoomFormSection h3 {
            color: #495057;
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f1f3f5;
        }

        #roomsContainer {
            min-height: 60px;
            margin-bottom: 30px;
        }

        .empty-state {
            color: #adb5bd;
            font-size: 0.9rem;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }

        .room-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .room-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .room-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .room-icon {
            font-size: 1.5rem;
        }

        .room-name {
            font-weight: 600;
            color: #333;
            font-size: 1rem;
            flex: 1;
        }

        .room-type-badge {
            background: #667eea;
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .room-details {
            color: #6c757d;
            font-size: 0.85rem;
            margin-bottom: 10px;
        }

        .glass-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .room-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .edit-room-btn,
        .delete-room-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .edit-room-btn {
            background: #e9ecef;
            color: #495057;
        }

        .edit-room-btn:hover {
            background: #dee2e6;
        }

        .delete-room-btn {
            background: #fff5f5;
            color: #e53e3e;
        }

        .delete-room-btn:hover {
            background: #fed7d7;
        }

        .checkbox-group {
            margin-bottom: 20px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 600;
            color: #495057;
        }

        .checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-label span {
            font-weight: 500;
        }

        select {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.2s ease;
            font-family: inherit;
            background: white;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary.large {
            width: 100%;
            padding: 16px;
            font-size: 1.1rem;
            font-weight: 700;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .modal-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 30px;
        }

        @media (max-width: 640px) {
            #onboardingModal {
                padding: 30px 20px;
                max-height: 95vh;
            }

            #onboardingModal h2 {
                font-size: 1.5rem;
            }

            .room-header {
                flex-wrap: wrap;
            }

            .room-type-badge {
                order: 3;
                width: 100%;
                text-align: center;
                margin-top: 5px;
            }
        }

        /* Offline Status Indicator Styles */
        .offline-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f8d7da;
            color: #721c24;
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #f5c6cb;
            font-size: 0.9rem;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 2000;
            display: none;
            animation: slideInRight 0.3s ease;
        }

        .offline-indicator.show {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .offline-indicator .status-icon {
            font-size: 1.2rem;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Notification Toast Styles */
        .notification-toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            display: none;
            animation: slideInUp 0.3s ease;
            max-width: 350px;
            border-left: 4px solid #667eea;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .notification-toast.show {
            display: block;
        }

        .notification-toast.success {
            border-left-color: #28a745;
        }

        .notification-toast.info {
            border-left-color: #17a2b8;
        }

        .notification-toast.warning {
            border-left-color: #ffc107;
        }

        .notification-toast.error {
            border-left-color: #dc3545;
        }

        .notification-toast .toast-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .notification-toast .toast-icon {
            font-size: 1.5rem;
        }

        .notification-toast .toast-message {
            color: #333;
            font-size: 0.95rem;
            font-weight: 500;
        }

        /* Connection Status Badge in Header */
        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: #d4edda;
            color: #155724;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 10px;
            margin-left: 8px;
        }

        .connection-status.offline {
            background: #f8d7da;
            color: #721c24;
        }

        .connection-status .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #28a745;
        }

        .connection-status.offline .status-dot {
            background: #dc3545;
        }

        /* Sync Queue Indicator */
        .sync-queue-indicator {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: #fff3cd;
            color: #856404;
            padding: 12px 20px;
            border-radius: 8px;
            border: 2px solid #ffeaa7;
            font-size: 0.85rem;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 1500;
            display: none;
            animation: pulse 2s infinite;
        }

        .sync-queue-indicator.show {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @media (max-width: 480px) {
            .offline-indicator,
            .notification-toast,
            .sync-queue-indicator {
                left: 15px;
                right: 15px;
                max-width: calc(100% - 30px);
            }

            .connection-status {
                display: none;
            }
        }

        /* Settings Modal Styles */
        #settingsOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        #settingsModal {
            background: white;
            border-radius: 20px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
            animation: slideUp 0.3s ease;
            padding: 0;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 30px 40px 20px;
            border-bottom: 2px solid #f1f3f5;
        }

        .modal-header h2 {
            color: #333;
            font-size: 1.8rem;
            font-weight: 700;
            margin: 0;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 2rem;
            color: #adb5bd;
            cursor: pointer;
            transition: color 0.2s ease;
            line-height: 1;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-modal-btn:hover {
            color: #495057;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #e9ecef;
            padding: 0 40px;
            background: #f8f9fa;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 15px 20px;
            font-size: 0.95rem;
            font-weight: 600;
            color: #6c757d;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .tab-btn:hover {
            color: #495057;
            background: #fff;
        }

        .tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #fff;
        }

        .tab-content {
            padding: 30px 40px;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        .tab-pane h3 {
            color: #333;
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .tab-description {
            color: #6c757d;
            font-size: 0.9rem;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        /* Settings Room List */
        #settingsRoomsList {
            margin-bottom: 20px;
            min-height: 80px;
        }

        .settings-room-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .settings-room-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .settings-room-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .room-reorder-controls {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .reorder-btn {
            background: #e9ecef;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 20px;
            cursor: pointer;
            font-size: 0.7rem;
            color: #495057;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reorder-btn:hover:not(:disabled) {
            background: #dee2e6;
            color: #212529;
        }

        .reorder-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Keystone Items */
        .keystone-item {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .keystone-toggle {
            flex-shrink: 0;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        .keystone-info {
            flex: 1;
        }

        .keystone-default-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .keystone-custom-name {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .keystone-custom-name:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .keystone-custom-name::placeholder {
            color: #adb5bd;
            font-style: italic;
        }

        /* Task Preview */
        .preview-task-item {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
            transition: all 0.2s ease;
        }

        .preview-task-item.current {
            background: #e7f3ff;
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
        }

        .task-number {
            background: #667eea;
            color: white;
            font-weight: 700;
            font-size: 0.85rem;
            padding: 6px 12px;
            border-radius: 8px;
            min-width: 35px;
            text-align: center;
        }

        .preview-task-item.current .task-number {
            background: linear-gradient(45deg, #667eea, #764ba2);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .task-description {
            flex: 1;
            color: #333;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .task-meta {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge.pillar {
            background: #e7f3ff;
            color: #0066cc;
        }

        .badge.keystone {
            background: #fff5e6;
            color: #cc7a00;
        }

        .preview-legend {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .legend-items {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .legend-text {
            color: #6c757d;
            font-size: 0.85rem;
        }

        .progress-text {
            color: #495057;
            font-size: 0.95rem;
            font-weight: 500;
        }

        /* Account Info */
        .account-info {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #6c757d;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .info-value {
            color: #333;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .account-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Notice Styles */
        .notice-warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .notice-warning p {
            color: #856404;
            font-size: 0.9rem;
            margin: 0;
            font-weight: 500;
        }

        /* Modal Actions */
        .modal-actions {
            padding: 20px 40px 30px;
            border-top: 2px solid #f1f3f5;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn-danger {
            background: #e53e3e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-danger:hover {
            background: #c53030;
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.3);
        }

        /* Responsive adjustments for Settings Modal */
        @media (max-width: 768px) {
            #settingsModal {
                max-width: 100%;
                border-radius: 0;
            }

            .modal-header,
            .tab-content,
            .tabs {
                padding-left: 20px;
                padding-right: 20px;
            }

            .modal-actions {
                padding-left: 20px;
                padding-right: 20px;
            }

            .tabs {
                overflow-x: auto;
                white-space: nowrap;
            }

            .tab-btn {
                padding: 12px 15px;
                font-size: 0.85rem;
            }

            .legend-items {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Offline Status Indicator -->
    <div class="offline-indicator" id="offlineIndicator">
        <span class="status-icon">&#9888;</span>
        <span>You're offline. Changes will sync when reconnected.</span>
    </div>

    <!-- Notification Toast -->
    <div class="notification-toast" id="notificationToast">
        <div class="toast-content">
            <span class="toast-icon" id="toastIcon"></span>
            <span class="toast-message" id="toastMessage"></span>
        </div>
    </div>

    <!-- Sync Queue Indicator -->
    <div class="sync-queue-indicator" id="syncQueueIndicator">
        <span>&#8987;</span>
        <span id="syncQueueText">Pending sync...</span>
    </div>

    <div class="container">
        <!-- User Header -->
        <div class="user-header">
            <div class="user-status" id="userStatus">
                <span class="status-badge" id="statusBadge">Guest</span>
                <span class="user-email" id="userEmail" style="display: none;"></span>
                <span class="connection-status" id="connectionStatus">
                    <span class="status-dot"></span>
                    <span id="connectionText">Online</span>
                </span>
            </div>
            <div class="user-actions">
                <button class="header-button" id="settingsButton" style="display: none;">Settings</button>
                <button class="header-button" id="loginButton">Sign In</button>
                <button class="header-button secondary" id="logoutButton" style="display: none;">Sign Out</button>
            </div>
        </div>

        <!-- Migration Banner (Phase 7: for existing users without room configuration) -->
        <div id="migrationBanner" style="display: none;">
            <div class="banner info">
                <p>
                    <strong>âœ¨ New Feature!</strong>
                    Get personalized cleaning tasks based on your home setup.
                    <a href="#" onclick="openSettingsModal(); return false;">
                        Configure your rooms now
                    </a>
                </p>
                <button class="banner-close" onclick="dismissMigrationBanner()">Ã—</button>
            </div>
        </div>

        <h1>Daily Clean</h1>

        <div class="task-card">
            <!-- Progress indicator (only for configured users) -->
            <div id="taskProgress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 0%"></div>
                </div>
                <p class="progress-text">
                    Task <strong id="currentPosition">1</strong> of
                    <strong id="totalTasks">28</strong>
                </p>
            </div>

            <!-- Task description -->
            <div class="task-text" id="taskText"></div>

            <!-- Context badge (only for rotation tasks) -->
            <div id="taskContext" style="display: none;">
                <span id="taskBadge" class="badge"></span>
            </div>

            <!-- Legacy user prompt -->
            <div id="legacyPrompt" style="display: none;">
                <p class="info-box">
                    ðŸ’¡ <strong>Personalize your tasks!</strong>
                    <a href="#" onclick="openSettingsModal(); return false;">Configure your home</a> to get room-specific tasks.
                </p>
            </div>
        </div>

        <div class="streak-counter">
            <div class="streak-text" id="streakText"></div>
        </div>

        <button class="done-button" id="doneButton">
            Done!
        </button>

        <div class="completed-message" id="completedMessage">
            Already completed today! Come back tomorrow for your next task.
        </div>
    </div>

    <!-- Authentication Modal Overlay -->
    <div id="authOverlay" style="display: none;">
        <div id="authModal">
            <!-- Login Form -->
            <div id="loginForm" class="auth-form">
                <h2>Welcome Back!</h2>
                <p class="auth-subtitle">Sign in to sync your streak across devices</p>

                <form id="loginFormElement">
                    <div class="form-group">
                        <label for="loginEmail">Email</label>
                        <input type="email" id="loginEmail" name="email" required autocomplete="email" placeholder="you@example.com">
                    </div>

                    <div class="form-group">
                        <label for="loginPassword">Password</label>
                        <input type="password" id="loginPassword" name="password" required autocomplete="current-password" placeholder="Enter your password">
                    </div>

                    <div class="form-error" id="loginError"></div>

                    <button type="submit" class="auth-button" id="loginSubmitButton">
                        <span class="button-text">Sign In</span>
                        <span class="button-loading" style="display: none;">Signing in...</span>
                    </button>
                </form>

                <div class="auth-footer">
                    <p>Don't have an account? <a href="#" id="showRegisterLink">Create one</a></p>
                </div>

                <button class="close-modal" id="closeLoginModal" aria-label="Close">&times;</button>
            </div>

            <!-- Register Form -->
            <div id="registerForm" class="auth-form" style="display: none;">
                <h2>Create Account</h2>
                <p class="auth-subtitle">Start syncing your cleaning streak today</p>

                <form id="registerFormElement">
                    <div class="form-group">
                        <label for="registerEmail">Email</label>
                        <input type="email" id="registerEmail" name="email" required autocomplete="email" placeholder="you@example.com">
                    </div>

                    <div class="form-group">
                        <label for="registerPassword">Password</label>
                        <input type="password" id="registerPassword" name="password" required autocomplete="new-password" placeholder="At least 8 characters">
                        <small class="form-hint">Use 8+ characters with letters, numbers, and symbols</small>
                    </div>

                    <div class="form-group">
                        <label for="registerConfirmPassword">Confirm Password</label>
                        <input type="password" id="registerConfirmPassword" name="confirmPassword" required autocomplete="new-password" placeholder="Confirm your password">
                    </div>

                    <div class="form-error" id="registerError"></div>

                    <button type="submit" class="auth-button" id="registerSubmitButton">
                        <span class="button-text">Create Account</span>
                        <span class="button-loading" style="display: none;">Creating account...</span>
                    </button>
                </form>

                <div class="auth-footer">
                    <p>Already have an account? <a href="#" id="showLoginLink">Sign in</a></p>
                </div>

                <button class="close-modal" id="closeRegisterModal" aria-label="Close">&times;</button>
            </div>
        </div>
    </div>

    <!-- Onboarding Modal Overlay -->
    <div id="onboardingOverlay" style="display: none;">
        <div id="onboardingModal">
            <h2>Welcome! Let's Set Up Your Home</h2>
            <p class="onboarding-subtitle">Configure your rooms to get personalized cleaning tasks based on the three-pillars methodology.</p>

            <div id="roomConfigSection">
                <!-- Configured rooms display -->
                <div id="configuredRoomsList">
                    <h3>Your Rooms</h3>
                    <div id="roomsContainer">
                        <p class="empty-state">No rooms added yet. Add your first room below!</p>
                    </div>
                </div>

                <!-- Add room form -->
                <div id="addRoomFormSection">
                    <h3>Add a Room</h3>
                    <form id="roomForm">
                        <div class="form-group">
                            <label for="roomType">Room Type</label>
                            <select id="roomType" required>
                                <option value="">Select room type...</option>
                                <option value="living_room">Living Room</option>
                                <option value="bedroom">Bedroom</option>
                                <option value="kitchen">Kitchen</option>
                                <option value="bathroom">Bathroom</option>
                                <option value="office">Office</option>
                                <option value="dining_room">Dining Room</option>
                                <option value="laundry">Laundry Room</option>
                                <option value="garage">Garage</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="customRoomName">Custom Name</label>
                            <input type="text" id="customRoomName"
                                   placeholder="e.g., Master Bedroom"
                                   maxlength="50" required>
                            <small class="form-hint">Give this room a specific name (e.g., "Master Bedroom", "Guest Bathroom")</small>
                        </div>

                        <div class="form-group checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="hasGlass" checked>
                                <span>This room has mirrors or windows</span>
                            </label>
                            <small class="form-hint">Uncheck if this room has no glass surfaces to clean</small>
                        </div>

                        <button type="submit" class="btn-primary">Add Room</button>
                    </form>
                </div>
            </div>

            <!-- Action buttons -->
            <div class="modal-actions">
                <button id="finishOnboarding" class="btn-primary large" disabled>
                    Generate My Tasks
                </button>
                <button id="skipOnboarding" class="btn-secondary">Skip for Now</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal Overlay -->
    <div id="settingsOverlay" style="display: none;">
        <div id="settingsModal">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="close-modal-btn" id="closeSettingsModal" aria-label="Close">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab-btn active" data-tab="rooms">My Rooms</button>
                <button class="tab-btn" data-tab="keystones">Keystone Tasks</button>
                <button class="tab-btn" data-tab="preview">Task Preview</button>
                <button class="tab-btn" data-tab="account">Account</button>
            </div>

            <!-- Tab Contents -->
            <div class="tab-content">
                <!-- My Rooms Tab -->
                <div id="roomsTab" class="tab-pane active">
                    <div id="settingsRoomsList">
                        <!-- Room cards will be rendered here -->
                    </div>

                    <button id="addRoomSettingsBtn" class="btn-primary">
                        + Add Room
                    </button>

                    <!-- Add Room Form (hidden initially) -->
                    <div id="addRoomInSettings" style="display: none;">
                        <h3>Add a New Room</h3>
                        <form id="roomFormSettings">
                            <div class="form-group">
                                <label for="roomTypeSettings">Room Type</label>
                                <select id="roomTypeSettings" required>
                                    <option value="">Select room type...</option>
                                    <option value="living_room">Living Room</option>
                                    <option value="bedroom">Bedroom</option>
                                    <option value="kitchen">Kitchen</option>
                                    <option value="bathroom">Bathroom</option>
                                    <option value="office">Office</option>
                                    <option value="dining_room">Dining Room</option>
                                    <option value="laundry">Laundry Room</option>
                                    <option value="garage">Garage</option>
                                </select>
                            </div>

                            <div class="form-group">
                                <label for="customRoomNameSettings">Custom Name</label>
                                <input type="text" id="customRoomNameSettings"
                                       placeholder="e.g., Master Bedroom"
                                       maxlength="50" required>
                            </div>

                            <div class="form-group checkbox-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="hasGlassSettings" checked>
                                    <span>This room has mirrors or windows</span>
                                </label>
                            </div>

                            <div class="form-actions">
                                <button type="submit" class="btn-primary">Add Room</button>
                                <button type="button" class="btn-secondary" id="cancelAddRoomSettings">Cancel</button>
                            </div>
                        </form>
                    </div>

                    <!-- Pending changes notice -->
                    <div id="pendingChangesNotice" class="notice-warning" style="display: none;">
                        <p>Your changes will be applied after you complete the current rotation cycle.</p>
                    </div>
                </div>

                <!-- Keystone Tasks Tab -->
                <div id="keystonesTab" class="tab-pane">
                    <h3>High-Frequency Hygiene Points</h3>
                    <p class="tab-description">Enable/disable keystone tasks and customize their names. These tasks are interspersed throughout your rotation.</p>

                    <div id="keystonesList">
                        <!-- Keystone items will be rendered here -->
                    </div>
                </div>

                <!-- Task Preview Tab -->
                <div id="previewTab" class="tab-pane">
                    <h3>Your Task Rotation</h3>
                    <p class="tab-description">Preview your upcoming tasks in the rotation.</p>

                    <div id="taskPreviewList">
                        <!-- Task preview items will be rendered here -->
                    </div>

                    <div class="preview-legend">
                        <div class="legend-items">
                            <span class="legend-item">
                                <span class="badge pillar">Pillar Task</span>
                                <span class="legend-text">Room-based cleaning task</span>
                            </span>
                            <span class="legend-item">
                                <span class="badge keystone">Keystone</span>
                                <span class="legend-text">High-frequency hygiene point</span>
                            </span>
                        </div>
                        <p class="progress-text">Current position: <strong id="currentPositionPreview">-</strong> / <strong id="totalTasksPreview">-</strong></p>
                    </div>
                </div>

                <!-- Account Tab -->
                <div id="accountTab" class="tab-pane">
                    <h3>Account Settings</h3>
                    <div class="account-info">
                        <div class="info-row">
                            <span class="info-label">Email:</span>
                            <span class="info-value" id="accountEmail">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Account Created:</span>
                            <span class="info-value" id="accountCreated">-</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Total Completions:</span>
                            <span class="info-value" id="accountCompletions">-</span>
                        </div>
                    </div>

                    <div class="account-actions">
                        <button class="btn-secondary" id="changePasswordBtn">Change Password</button>
                        <button class="btn-danger" id="deleteAccountBtn">Delete Account</button>
                    </div>
                </div>
            </div>

            <!-- Modal Actions -->
            <div class="modal-actions">
                <button id="saveSettingsBtn" class="btn-primary">Save Changes</button>
                <button class="btn-secondary" id="cancelSettingsBtn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CONSTANTS AND CONFIGURATION
        // ============================================
        const API_BASE_URL = 'http://localhost:3000/api';
        const API_TIMEOUT = 10000; // 10 seconds

        const cleaningTasks = [
            "Make your bed",
            "Wipe down kitchen counters",
            "Clean bathroom mirror",
            "Dust living room TV",
            "Organize one drawer",
            "Vacuum entryway",
            "Wipe down light switches",
            "Clean coffee table",
            "Tidy up couch cushions",
            "Wipe down door handles",
            "Clean kitchen sink",
            "Organize desk workspace",
            "Dust nightstand",
            "Wipe bathroom counter",
            "Sweep kitchen floor",
            "Clean toilet seat and rim",
            "Organize medicine cabinet",
            "Dust picture frames",
            "Wipe down refrigerator exterior",
            "Clean computer keyboard",
            "Organize bookshelf",
            "Dust ceiling fan blades",
            "Wipe down dining table",
            "Clean microwave interior",
            "Organize closet floor",
            "Dust windowsills",
            "Clean shower door or curtain",
            "Wipe down baseboards in one room",
            "Organize pantry shelf",
            "Clean bathroom faucet",
            "Dust lamp shades",
            "Wipe down kitchen appliances",
            "Organize junk drawer",
            "Clean mirror in bedroom",
            "Vacuum stairs",
            "Wipe down trash cans",
            "Organize shoes by front door",
            "Clean inside of dishwasher",
            "Dust electronics",
            "Wipe down cabinet fronts",
            "Organize bathroom drawer",
            "Clean stovetop",
            "Dust coffee table books",
            "Wipe down washing machine",
            "Organize coat closet",
            "Clean bathroom scale",
            "Dust dining chairs",
            "Wipe down phone and chargers",
            "Organize one kitchen cabinet",
            "Clean out car cup holders"
        ];

        // ============================================
        // API COMMUNICATION LAYER (Step 25)
        // ============================================

        /**
         * Make an authenticated API request with error handling
         * @param {string} endpoint - API endpoint path (e.g., '/auth/register')
         * @param {object} options - Fetch options (method, body, etc.)
         * @returns {Promise<object>} Response data
         */
        async function apiRequest(endpoint, options = {}) {
            const url = `${API_BASE_URL}${endpoint}`;

            const defaultOptions = {
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'include', // Include cookies for JWT
                ...options
            };

            // Merge headers properly
            if (options.headers) {
                defaultOptions.headers = {
                    ...defaultOptions.headers,
                    ...options.headers
                };
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT);

                const response = await fetch(url, {
                    ...defaultOptions,
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                // Parse response
                let data;
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    data = await response.json();
                } else {
                    data = { message: await response.text() };
                }

                // Handle non-OK responses
                if (!response.ok) {
                    const error = new Error(data.message || `HTTP ${response.status}`);
                    error.status = response.status;
                    error.data = data;
                    throw error;
                }

                return data;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error('Request timeout - please check your connection');
                }

                // Network errors
                if (error instanceof TypeError) {
                    throw new Error('Network error - please check your connection');
                }

                // Re-throw API errors with message
                throw error;
            }
        }

        /**
         * Authentication API Methods
         */
        const AuthAPI = {
            /**
             * Register a new user
             * @param {string} email - User email
             * @param {string} password - User password
             * @param {string} confirmPassword - Password confirmation
             * @returns {Promise<object>} User data and session info
             */
            async register(email, password, confirmPassword) {
                return apiRequest('/auth/register', {
                    method: 'POST',
                    body: JSON.stringify({ email, password, confirmPassword })
                });
            },

            /**
             * Login existing user
             * @param {string} email - User email
             * @param {string} password - User password
             * @returns {Promise<object>} User data and session info
             */
            async login(email, password) {
                return apiRequest('/auth/login', {
                    method: 'POST',
                    body: JSON.stringify({ email, password })
                });
            },

            /**
             * Logout current user
             * @returns {Promise<object>} Logout confirmation
             */
            async logout() {
                return apiRequest('/auth/logout', {
                    method: 'POST'
                });
            },

            /**
             * Get current user session
             * @returns {Promise<object>} Current user data
             */
            async getSession() {
                return apiRequest('/auth/session', {
                    method: 'GET'
                });
            }
        };

        /**
         * User Data API Methods
         */
        const UserAPI = {
            /**
             * Get user profile
             * @returns {Promise<object>} User profile data
             */
            async getProfile() {
                return apiRequest('/user/profile', {
                    method: 'GET'
                });
            },

            /**
             * Get all user streaks
             * @returns {Promise<object>} All streak statistics
             */
            async getStreaks() {
                return apiRequest('/user/streaks', {
                    method: 'GET'
                });
            },

            /**
             * Complete today's task
             * @param {string} taskDescription - Task that was completed
             * @returns {Promise<object>} Updated streak data
             */
            async completeTask(taskDescription) {
                return apiRequest('/user/complete', {
                    method: 'POST',
                    body: JSON.stringify({ taskName: taskDescription })
                });
            },

            /**
             * Get completion history
             * @param {number} limit - Number of records to retrieve
             * @param {number} offset - Pagination offset
             * @returns {Promise<object>} History records
             */
            async getHistory(limit = 30, offset = 0) {
                return apiRequest(`/user/history?limit=${limit}&offset=${offset}`, {
                    method: 'GET'
                });
            },

            /**
             * Get analytics data
             * @returns {Promise<object>} User analytics
             */
            async getAnalytics() {
                return apiRequest('/user/analytics', {
                    method: 'GET'
                });
            },

            /**
             * Update user preferences
             * @param {object} preferences - User preferences object
             * @returns {Promise<object>} Updated preferences
             */
            async updatePreferences(preferences) {
                return apiRequest('/user/preferences', {
                    method: 'PUT',
                    body: JSON.stringify({ preferences })
                });
            }
        };

        /**
         * Room Configuration API Methods
         */
        const RoomAPI = {
            /**
             * Create a new room
             * @param {object} roomData - Room configuration { roomType, customName, hasGlass }
             * @returns {Promise<object>} Created room object
             */
            async createRoom(roomData) {
                return apiRequest('/rooms', {
                    method: 'POST',
                    body: JSON.stringify(roomData)
                });
            },

            /**
             * Get all user rooms
             * @returns {Promise<object>} Array of room configurations
             */
            async getUserRooms() {
                return apiRequest('/rooms', {
                    method: 'GET'
                });
            },

            /**
             * Get room by ID
             * @param {string} roomId - Room ID
             * @returns {Promise<object>} Room object
             */
            async getRoomById(roomId) {
                return apiRequest(`/rooms/${roomId}`, {
                    method: 'GET'
                });
            },

            /**
             * Update room configuration
             * @param {string} roomId - Room ID
             * @param {object} updates - Room updates { customName?, hasGlass? }
             * @returns {Promise<object>} Updated room object
             */
            async updateRoom(roomId, updates) {
                return apiRequest(`/rooms/${roomId}`, {
                    method: 'PUT',
                    body: JSON.stringify(updates)
                });
            },

            /**
             * Delete a room
             * @param {string} roomId - Room ID
             * @returns {Promise<object>} Success confirmation
             */
            async deleteRoom(roomId) {
                return apiRequest(`/rooms/${roomId}`, {
                    method: 'DELETE'
                });
            },

            /**
             * Reorder rooms
             * @param {Array<string>} roomIds - Array of room IDs in desired order
             * @returns {Promise<object>} Success confirmation
             */
            async reorderRooms(roomIds) {
                return apiRequest('/rooms/reorder', {
                    method: 'PUT',
                    body: JSON.stringify({ room_order: roomIds })
                });
            }
        };

        /**
         * Task Rotation API Methods
         */
        const TaskAPI = {
            /**
             * Get current task from rotation
             * @returns {Promise<object>} Current task object
             */
            async getCurrentTask() {
                return apiRequest('/tasks/current', {
                    method: 'GET'
                });
            },

            /**
             * Preview upcoming tasks
             * @param {number} limit - Number of tasks to preview
             * @returns {Promise<object>} Array of upcoming tasks
             */
            async previewTasks(limit = 20) {
                return apiRequest(`/tasks/preview?limit=${limit}`, {
                    method: 'GET'
                });
            },

            /**
             * Regenerate task rotation
             * @returns {Promise<object>} New rotation info
             */
            async regenerateRotation() {
                return apiRequest('/tasks/regenerate', {
                    method: 'POST'
                });
            }
        };

        // ============================================
        // STATE MANAGEMENT SYSTEM (Step 26)
        // ============================================

        /**
         * Application State Object
         * Supports both anonymous (localStorage) and authenticated (API + cache) modes
         */
        const AppState = {
            // Core streak data
            streak: {
                current: 0,
                lastCompletedDate: null, // ISO string
                bestStreak: 0,
                history: [] // Array of completion date objects
            },

            // Current task (legacy format)
            task: {
                text: "",
                date: null,
                completed: false
            },

            // Current task (rotation-based format)
            currentTask: null, // { id, description, taskType, room, pillarType, keystoneType, position, totalTasks, isLegacy }

            // User authentication state
            user: {
                isAuthenticated: false,
                profile: null, // { id, email, createdAt, preferences }
                hasConfiguredRooms: false // Whether user has set up room customization
            },

            // Sync state
            sync: {
                status: 'idle', // 'idle' | 'syncing' | 'error'
                lastSyncTime: null,
                error: null,
                pendingChanges: false,
                offlineQueue: []
            },

            // Network state
            network: {
                isOnline: navigator.onLine
            },

            // UI state
            ui: {
                authModalVisible: false,
                authModalMode: 'login', // 'login' | 'register'
                loadingVisible: false
            },

            // Engagement tracking
            engagement: {
                totalCompletions: 0,
                consecutiveDays: 0,
                firstVisit: null,
                lastVisit: null,
                visitCount: 0,
                hasSeenAuthPrompt: false,
                dismissedAuthPromptCount: 0
            }
        };

        /**
         * Load state from localStorage
         * Supports both anonymous and authenticated modes
         */
        function loadState() {
            try {
                // Try authenticated state first
                const authenticatedData = localStorage.getItem('cleanStreak_authenticated_state');
                if (authenticatedData) {
                    const data = JSON.parse(authenticatedData);

                    // Restore state
                    Object.assign(AppState.user, data.user || {});
                    Object.assign(AppState.streak, data.streak || {});
                    Object.assign(AppState.engagement, data.engagement || {});

                    AppState.user.isAuthenticated = true;
                    return;
                }

                // Fall back to anonymous state
                const anonymousData = localStorage.getItem('cleanStreak_anonymous_state');
                if (anonymousData) {
                    const data = JSON.parse(anonymousData);

                    Object.assign(AppState.streak, data.streak || {});
                    Object.assign(AppState.engagement, data.engagement || {});
                }

                // Track visit
                AppState.engagement.visitCount++;
                AppState.engagement.lastVisit = new Date().toISOString();
                if (!AppState.engagement.firstVisit) {
                    AppState.engagement.firstVisit = new Date().toISOString();
                }
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }

        /**
         * Save state to localStorage
         */
        function saveState() {
            try {
                if (AppState.user.isAuthenticated) {
                    // Save authenticated state
                    const data = {
                        user: AppState.user,
                        streak: AppState.streak,
                        engagement: AppState.engagement,
                        lastSyncTime: AppState.sync.lastSyncTime || new Date().toISOString()
                    };
                    localStorage.setItem('cleanStreak_authenticated_state', JSON.stringify(data));
                } else {
                    // Save anonymous state
                    const data = {
                        streak: AppState.streak,
                        engagement: AppState.engagement,
                        lastSyncTime: new Date().toISOString()
                    };
                    localStorage.setItem('cleanStreak_anonymous_state', JSON.stringify(data));
                }
            } catch (error) {
                console.error('Error saving state:', error);
            }
        }

        /**
         * Clear all persisted state
         */
        function clearState() {
            localStorage.removeItem('cleanStreak_anonymous_state');
            localStorage.removeItem('cleanStreak_authenticated_state');
        }

        /**
         * Update UI to reflect current authentication state
         */
        function updateAuthUI() {
            const statusBadge = document.getElementById('statusBadge');
            const userEmail = document.getElementById('userEmail');
            const loginButton = document.getElementById('loginButton');
            const logoutButton = document.getElementById('logoutButton');
            const settingsButton = document.getElementById('settingsButton');

            if (AppState.user.isAuthenticated && AppState.user.profile) {
                // Authenticated state
                statusBadge.textContent = 'Authenticated';
                statusBadge.classList.add('authenticated');
                userEmail.textContent = AppState.user.profile.email;
                userEmail.style.display = 'block';
                loginButton.style.display = 'none';
                logoutButton.style.display = 'block';
                settingsButton.style.display = 'block';
            } else {
                // Anonymous state
                statusBadge.textContent = 'Guest';
                statusBadge.classList.remove('authenticated');
                userEmail.style.display = 'none';
                loginButton.style.display = 'block';
                logoutButton.style.display = 'none';
                settingsButton.style.display = 'none';
            }
        }

        // ============================================
        // DATA SYNCHRONIZATION FUNCTIONS (Step 28)
        // ============================================

        /**
         * Process offline queue - send queued actions to server
         * @returns {Promise<void>}
         */
        async function processOfflineQueue() {
            if (!AppState.user.isAuthenticated) return;
            if (!AppState.network.isOnline) return;
            if (AppState.sync.offlineQueue.length === 0) return;

            console.log(`Processing ${AppState.sync.offlineQueue.length} offline actions...`);

            const successfulActions = [];
            const failedActions = [];

            // Process each queued action
            for (const queuedAction of AppState.sync.offlineQueue) {
                try {
                    if (queuedAction.action === 'COMPLETE_TASK') {
                        await UserAPI.completeTask(queuedAction.payload.taskDescription);
                        successfulActions.push(queuedAction);
                        console.log('Synced offline task completion:', queuedAction.payload.taskDescription);
                    }
                    // Add more action types here as needed
                } catch (error) {
                    console.error('Failed to process offline action:', queuedAction, error);
                    queuedAction.retryCount++;

                    // Keep in queue if retry count < 3, otherwise drop it
                    if (queuedAction.retryCount < 3) {
                        failedActions.push(queuedAction);
                    } else {
                        console.warn('Dropping action after 3 failed retries:', queuedAction);
                    }
                }
            }

            // Update queue with only failed actions that should be retried
            AppState.sync.offlineQueue = failedActions;

            // Mark as having pending changes if queue is not empty
            AppState.sync.pendingChanges = failedActions.length > 0;

            console.log(`Offline queue processed: ${successfulActions.length} succeeded, ${failedActions.length} pending retry`);
        }

        /**
         * Push local changes to server
         * @returns {Promise<boolean>} Success status
         */
        async function pushLocalChangesToServer() {
            if (!AppState.user.isAuthenticated) return false;
            if (!AppState.network.isOnline) return false;

            try {
                // Check if there are local changes that need to be pushed
                // This is primarily for offline queue and any pending state changes

                // Process offline queue first
                await processOfflineQueue();

                // Additional sync logic could go here for other state changes
                // For now, task completions are the main sync point

                return true;
            } catch (error) {
                console.error('Error pushing local changes:', error);
                return false;
            }
        }

        /**
         * Fetch latest data from server and update local state
         * @returns {Promise<Object|null>} Server data or null on error
         */
        async function fetchServerData() {
            if (!AppState.user.isAuthenticated) return null;
            if (!AppState.network.isOnline) return null;

            try {
                // Fetch latest data from server (streaks, history, profile)
                const [streaksResponse, historyResponse, profileResponse] = await Promise.all([
                    UserAPI.getStreaks(),
                    UserAPI.getHistory(),
                    UserAPI.getProfile()
                ]);

                return {
                    streaks: streaksResponse,
                    history: historyResponse,
                    profile: profileResponse
                };
            } catch (error) {
                console.error('Error fetching server data:', error);
                return null;
            }
        }

        /**
         * Merge server data into local state
         * @param {Object} serverData - Data fetched from server
         */
        function mergeServerDataIntoLocalState(serverData) {
            if (!serverData) return;

            // Update streak data from server
            if (serverData.streaks && serverData.streaks.success && serverData.streaks.data) {
                const streaks = serverData.streaks.data.streaks || [];
                const stats = serverData.streaks.data.stats || {};

                // Server is the source of truth for streaks
                AppState.streak.current = stats.totalCurrentStreak || 0;
                AppState.streak.bestStreak = stats.bestOverallStreak || 0;

                // Find the most recent completion date from streaks
                if (streaks.length > 0) {
                    const mostRecent = streaks.reduce((latest, streak) => {
                        const streakDate = new Date(streak.lastCompletedAt);
                        const latestDate = latest ? new Date(latest) : new Date(0);
                        return streakDate > latestDate ? streak.lastCompletedAt : latest;
                    }, null);

                    if (mostRecent) {
                        AppState.streak.lastCompletedDate = new Date(mostRecent).toDateString();
                    }
                }

                // Build history from streaks (dates when tasks were completed)
                AppState.streak.history = streaks.map(streak =>
                    new Date(streak.lastCompletedAt).toDateString()
                );
            }

            // Update engagement from profile stats
            if (serverData.profile && serverData.profile.success && serverData.profile.data) {
                const profileStats = serverData.profile.data.stats || {};
                AppState.engagement.totalCompletions = profileStats.totalCompletions || 0;
                AppState.engagement.consecutiveDays = AppState.streak.current;
            }

            // Update task history for analytics
            if (serverData.history && serverData.history.success && serverData.history.data) {
                const historyItems = serverData.history.data.history || [];
                AppState.task.history = historyItems.map(item => ({
                    taskDescription: item.taskDescription,
                    completedAt: item.completedAt,
                    streakDay: item.streakDay || 0
                }));
            }

            console.log('Server data merged into local state');
        }

        /**
         * Main sync function - bi-directional sync between client and server
         * This is the primary sync function called throughout the app
         */
        async function syncWithServer() {
            if (!AppState.user.isAuthenticated) {
                console.log('Sync skipped: user not authenticated');
                return;
            }

            if (!AppState.network.isOnline) {
                console.log('Sync skipped: offline');
                return;
            }

            if (AppState.sync.status === 'syncing') {
                console.log('Sync already in progress, skipping...');
                return;
            }

            try {
                console.log('Starting data synchronization...');
                AppState.sync.status = 'syncing';
                AppState.sync.error = null;

                // Step 1: Push local changes to server (includes offline queue)
                await pushLocalChangesToServer();

                // Step 2: Fetch latest data from server
                const serverData = await fetchServerData();

                // Step 3: Check for conflicts and resolve if necessary
                if (serverData && hasConflict(AppState, serverData)) {
                    console.log('Conflict detected - applying resolution rules...');

                    // Resolve the conflict
                    const resolved = resolveConflict(AppState, serverData);

                    // Apply resolved state to AppState
                    Object.assign(AppState.streak, resolved.streak);
                    Object.assign(AppState.engagement, resolved.engagement);

                    // Push resolved state back to server to ensure consistency
                    // This ensures the server has the resolved "winning" values
                    try {
                        await UserAPI.updatePreferences({
                            resolvedStreak: resolved.streak,
                            resolvedEngagement: resolved.engagement
                        });
                        console.log('Resolved state pushed to server');
                    } catch (pushError) {
                        console.warn('Failed to push resolved state to server:', pushError);
                        // Continue anyway - local state is updated
                    }
                } else if (serverData) {
                    // Step 4: No conflict - merge server data into local state normally
                    mergeServerDataIntoLocalState(serverData);
                }

                // Step 5: Update sync metadata
                AppState.sync.lastSyncTime = new Date().toISOString();
                AppState.sync.status = 'idle';
                AppState.sync.error = null;
                AppState.sync.pendingChanges = AppState.sync.offlineQueue.length > 0;

                // Step 6: Save updated state to localStorage
                saveState();

                console.log('Data synchronization completed successfully');
            } catch (error) {
                console.error('Sync error:', error);
                AppState.sync.status = 'error';
                AppState.sync.error = error.message;

                // Save state even on error to persist the error status
                saveState();
            }
        }

        /**
         * Background sync scheduler - runs periodically for authenticated users
         * Syncs every 5 minutes when user is active
         */
        let syncIntervalId = null;

        function startBackgroundSync() {
            // Clear any existing interval
            if (syncIntervalId) {
                clearInterval(syncIntervalId);
            }

            // Only start background sync for authenticated users
            if (!AppState.user.isAuthenticated) return;

            console.log('Starting background sync (5-minute intervals)');

            // Sync immediately
            syncWithServer();

            // Then sync every 5 minutes
            syncIntervalId = setInterval(() => {
                if (AppState.user.isAuthenticated && AppState.network.isOnline) {
                    syncWithServer();
                }
            }, 5 * 60 * 1000); // 5 minutes
        }

        function stopBackgroundSync() {
            if (syncIntervalId) {
                clearInterval(syncIntervalId);
                syncIntervalId = null;
                console.log('Background sync stopped');
            }
        }

        /**
         * Force an immediate sync (can be called manually)
         */
        async function forceSyncNow() {
            console.log('Force sync requested...');
            await syncWithServer();
        }

        /**
         * Migrate anonymous data to authenticated account
         */
        async function migrateAnonymousData() {
            // Check if there's anonymous data to migrate
            const anonymousData = localStorage.getItem('cleanStreak_anonymous_state');
            if (!anonymousData) return;

            try {
                const data = JSON.parse(anonymousData);

                // If anonymous user has a streak, merge it
                if (data.streak && data.streak.current > 0) {
                    // Server-side migration would happen here via API
                    // For now, keep the higher streak value
                    if (data.streak.current > AppState.streak.current) {
                        AppState.streak.current = data.streak.current;
                        AppState.streak.lastCompletedDate = data.streak.lastCompletedDate;
                    }
                    if (data.streak.bestStreak > AppState.streak.bestStreak) {
                        AppState.streak.bestStreak = data.streak.bestStreak;
                    }
                }

                // Merge engagement data
                if (data.engagement) {
                    AppState.engagement.totalCompletions += data.engagement.totalCompletions || 0;
                }

                // Clear anonymous data
                localStorage.removeItem('cleanStreak_anonymous_state');

                saveState();
            } catch (error) {
                console.error('Migration error:', error);
            }
        }

        // ============================================
        // CONFLICT RESOLUTION LOGIC (Step 29)
        // ============================================

        /**
         * Detect if there's a conflict between local and server state
         * @param {Object} localState - Current local AppState
         * @param {Object} serverData - Server data from fetchServerData()
         * @returns {boolean} True if conflict detected
         */
        function hasConflict(localState, serverData) {
            if (!serverData || !serverData.streaks || !serverData.streaks.success) {
                return false;
            }

            const serverStats = serverData.streaks.data?.stats || {};
            const serverStreaks = serverData.streaks.data?.streaks || [];

            // Check for streak value conflicts
            const streakDiffers = localState.streak.current !== (serverStats.totalCurrentStreak || 0);

            // Check for last completion date conflicts
            let lastCompletionDiffers = false;
            if (serverStreaks.length > 0) {
                const mostRecentServer = serverStreaks.reduce((latest, streak) => {
                    const streakDate = new Date(streak.lastCompletedAt);
                    const latestDate = latest ? new Date(latest) : new Date(0);
                    return streakDate > latestDate ? streak.lastCompletedAt : latest;
                }, null);

                if (mostRecentServer) {
                    const serverDateString = new Date(mostRecentServer).toDateString();
                    lastCompletionDiffers = localState.streak.lastCompletedDate !== serverDateString;
                }
            }

            // Check for best streak conflicts
            const bestStreakDiffers = localState.streak.bestStreak !== (serverStats.bestOverallStreak || 0);

            const hasConflict = streakDiffers || lastCompletionDiffers || bestStreakDiffers;

            if (hasConflict) {
                console.log('Conflict detected between local and server state', {
                    localCurrent: localState.streak.current,
                    serverCurrent: serverStats.totalCurrentStreak,
                    localLast: localState.streak.lastCompletedDate,
                    serverLast: mostRecentServer,
                    localBest: localState.streak.bestStreak,
                    serverBest: serverStats.bestOverallStreak
                });
            }

            return hasConflict;
        }

        /**
         * Resolve conflicts between local and server state
         * Implements the conflict resolution rules from state-management-design.md
         * @param {Object} localState - Current local AppState
         * @param {Object} serverData - Server data from fetchServerData()
         * @returns {Object} Resolved state to apply
         */
        function resolveConflict(localState, serverData) {
            console.log('Resolving conflict between local and server state...');

            const resolved = {
                streak: {},
                engagement: {}
            };

            const serverStats = serverData.streaks?.data?.stats || {};
            const serverStreaks = serverData.streaks?.data?.streaks || [];
            const serverProfile = serverData.profile?.data || {};
            const serverHistory = serverData.history?.data?.history || [];

            // ============================================
            // RULE 1: Server wins for historical data (source of truth)
            // ============================================
            resolved.streak.history = serverStreaks.map(streak =>
                new Date(streak.lastCompletedAt).toDateString()
            );

            // ============================================
            // RULE 2: Higher streak value wins
            // ============================================
            const serverCurrentStreak = serverStats.totalCurrentStreak || 0;
            const localCurrentStreak = localState.streak.current || 0;

            resolved.streak.current = Math.max(serverCurrentStreak, localCurrentStreak);

            console.log('Streak resolution: server=' + serverCurrentStreak + ', local=' + localCurrentStreak + ', resolved=' + resolved.streak.current);

            // ============================================
            // RULE 3: Most recent completion date wins
            // ============================================
            let serverLastDate = null;
            if (serverStreaks.length > 0) {
                const mostRecent = serverStreaks.reduce((latest, streak) => {
                    const streakDate = new Date(streak.lastCompletedAt);
                    const latestDate = latest ? new Date(latest) : new Date(0);
                    return streakDate > latestDate ? streak.lastCompletedAt : latest;
                }, null);

                if (mostRecent) {
                    serverLastDate = new Date(mostRecent).toDateString();
                }
            }

            const localLastDate = localState.streak.lastCompletedDate;

            if (serverLastDate && localLastDate) {
                const serverDate = new Date(serverLastDate);
                const localDate = new Date(localLastDate);
                resolved.streak.lastCompletedDate = localDate > serverDate ? localLastDate : serverLastDate;
            } else {
                resolved.streak.lastCompletedDate = serverLastDate || localLastDate;
            }

            console.log('Last completion date resolution: server=' + serverLastDate + ', local=' + localLastDate + ', resolved=' + resolved.streak.lastCompletedDate);

            // ============================================
            // RULE 4: Higher best streak wins
            // ============================================
            const serverBestStreak = serverStats.bestOverallStreak || 0;
            const localBestStreak = localState.streak.bestStreak || 0;

            resolved.streak.bestStreak = Math.max(serverBestStreak, localBestStreak);

            console.log('Best streak resolution: server=' + serverBestStreak + ', local=' + localBestStreak + ', resolved=' + resolved.streak.bestStreak);

            // ============================================
            // RULE 5: Merge engagement metrics (server as primary source)
            // ============================================
            // For total completions, use server data as it's the source of truth
            resolved.engagement.totalCompletions = serverProfile.stats?.totalCompletions || localState.engagement.totalCompletions || 0;

            // Update consecutive days to match current streak
            resolved.engagement.consecutiveDays = resolved.streak.current;

            // Keep earliest first visit
            const localFirst = localState.engagement.firstVisit ? new Date(localState.engagement.firstVisit) : null;
            const serverFirst = serverProfile.createdAt ? new Date(serverProfile.createdAt) : null;

            if (localFirst && serverFirst) {
                resolved.engagement.firstVisit = localFirst < serverFirst
                    ? localState.engagement.firstVisit
                    : serverProfile.createdAt;
            } else {
                resolved.engagement.firstVisit = localState.engagement.firstVisit || serverProfile.createdAt;
            }

            // Preserve local engagement tracking flags (these are client-side only)
            resolved.engagement.lastVisit = localState.engagement.lastVisit;
            resolved.engagement.visitCount = localState.engagement.visitCount;
            resolved.engagement.hasSeenAuthPrompt = localState.engagement.hasSeenAuthPrompt;
            resolved.engagement.dismissedAuthPromptCount = localState.engagement.dismissedAuthPromptCount;

            console.log('Conflict resolution complete:', resolved);

            return resolved;
        }

        // ============================================
        // OFFLINE FUNCTIONALITY ENHANCEMENTS (Step 30)
        // ============================================

        /**
         * Show notification toast
         * @param {string} message - Message to display
         * @param {string} type - Type of notification: success, info, warning, error
         * @param {number} duration - Duration in milliseconds (default: 4000)
         */
        function showNotification(message, type = 'info', duration = 4000) {
            const toast = document.getElementById('notificationToast');
            const icon = document.getElementById('toastIcon');
            const messageEl = document.getElementById('toastMessage');

            // Set icon based on type
            const icons = {
                success: '&#10004;',
                info: '&#9432;',
                warning: '&#9888;',
                error: '&#10006;'
            };

            icon.innerHTML = icons[type] || icons.info;
            messageEl.textContent = message;

            // Reset classes
            toast.className = 'notification-toast show ' + type;

            // Auto-hide after duration
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        /**
         * Update connection status indicator in UI
         */
        function updateConnectionStatus() {
            const offlineIndicator = document.getElementById('offlineIndicator');
            const connectionStatus = document.getElementById('connectionStatus');
            const connectionText = document.getElementById('connectionText');

            if (AppState.network.isOnline) {
                // Online state
                offlineIndicator.classList.remove('show');
                connectionStatus.classList.remove('offline');
                connectionText.textContent = 'Online';
            } else {
                // Offline state
                offlineIndicator.classList.add('show');
                connectionStatus.classList.add('offline');
                connectionText.textContent = 'Offline';
            }
        }

        /**
         * Update sync queue indicator
         */
        function updateSyncQueueIndicator() {
            const syncQueueIndicator = document.getElementById('syncQueueIndicator');
            const syncQueueText = document.getElementById('syncQueueText');

            const queueLength = AppState.sync.offlineQueue.length;

            if (queueLength > 0) {
                syncQueueIndicator.classList.add('show');
                syncQueueText.textContent = queueLength === 1
                    ? '1 action pending sync...'
                    : `${queueLength} actions pending sync...`;
            } else {
                syncQueueIndicator.classList.remove('show');
            }
        }

        /**
         * Handle when app goes offline
         */
        function handleOffline() {
            console.log('Network status: OFFLINE');
            AppState.network.isOnline = false;
            updateConnectionStatus();

            // Only show notification if user is authenticated (anonymous users don't sync anyway)
            if (AppState.user.isAuthenticated) {
                showNotification('You\'re offline. Changes will sync when reconnected.', 'warning', 6000);
            }

            saveState();
        }

        /**
         * Handle when app comes back online
         */
        async function handleOnline() {
            console.log('Network status: ONLINE');
            AppState.network.isOnline = true;
            updateConnectionStatus();

            // Show notification
            if (AppState.user.isAuthenticated) {
                showNotification('Connection restored! Syncing data...', 'success', 3000);
            }

            // Process offline queue if user is authenticated
            if (AppState.user.isAuthenticated) {
                const queueLength = AppState.sync.offlineQueue.length;

                if (queueLength > 0) {
                    console.log(`Processing ${queueLength} queued actions after reconnection...`);

                    // Process the offline queue
                    await processOfflineQueue();

                    // Sync with server to get latest data
                    await syncWithServer();

                    // Update queue indicator
                    updateSyncQueueIndicator();

                    // Show success notification
                    const remainingQueue = AppState.sync.offlineQueue.length;
                    if (remainingQueue === 0) {
                        showNotification('All changes synced successfully!', 'success', 3000);
                    } else if (remainingQueue < queueLength) {
                        showNotification(`${queueLength - remainingQueue} of ${queueLength} changes synced. ${remainingQueue} pending retry.`, 'warning', 4000);
                    }
                } else {
                    // Just sync to get latest server data
                    await syncWithServer();
                }
            }

            saveState();
        }

        /**
         * Enhanced queue processing with better error handling
         */
        async function processOfflineQueueEnhanced() {
            if (!AppState.user.isAuthenticated) return;
            if (!AppState.network.isOnline) return;
            if (AppState.sync.offlineQueue.length === 0) return;

            console.log(`Processing ${AppState.sync.offlineQueue.length} offline actions...`);

            const successfulActions = [];
            const failedActions = [];

            // Update indicator at start
            updateSyncQueueIndicator();

            // Process each queued action
            for (const queuedAction of AppState.sync.offlineQueue) {
                try {
                    if (queuedAction.action === 'COMPLETE_TASK') {
                        await UserAPI.completeTask(queuedAction.payload.taskDescription);
                        successfulActions.push(queuedAction);
                        console.log('Synced offline task completion:', queuedAction.payload.taskDescription);
                    }
                    // Add more action types here as needed
                } catch (error) {
                    console.error('Failed to process offline action:', queuedAction, error);
                    queuedAction.retryCount = (queuedAction.retryCount || 0) + 1;

                    // Keep in queue if retry count < 3, otherwise drop it
                    if (queuedAction.retryCount < 3) {
                        failedActions.push(queuedAction);
                    } else {
                        console.warn('Dropping action after 3 failed retries:', queuedAction);
                    }
                }
            }

            // Update queue with only failed actions that should be retried
            AppState.sync.offlineQueue = failedActions;

            // Mark as having pending changes if queue is not empty
            AppState.sync.pendingChanges = failedActions.length > 0;

            // Update indicator after processing
            updateSyncQueueIndicator();

            // Save state
            saveState();

            console.log(`Offline queue processed: ${successfulActions.length} succeeded, ${failedActions.length} pending retry`);

            return {
                succeeded: successfulActions.length,
                failed: failedActions.length
            };
        }

        /**
         * Check if app is truly online by pinging the API
         * @returns {Promise<boolean>} True if server is reachable
         */
        async function checkServerConnectivity() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    signal: AbortSignal.timeout(5000) // 5 second timeout
                });

                return response.ok;
            } catch (error) {
                console.log('Server connectivity check failed:', error.message);
                return false;
            }
        }

        /**
         * Periodic connectivity check for authenticated users
         * Runs every 30 seconds to detect server availability
         */
        let connectivityCheckInterval = null;

        function startConnectivityMonitoring() {
            // Clear any existing interval
            if (connectivityCheckInterval) {
                clearInterval(connectivityCheckInterval);
            }

            // Only monitor if user is authenticated
            if (!AppState.user.isAuthenticated) return;

            console.log('Starting connectivity monitoring');

            // Check every 30 seconds
            connectivityCheckInterval = setInterval(async () => {
                if (AppState.network.isOnline && AppState.user.isAuthenticated) {
                    const serverReachable = await checkServerConnectivity();

                    if (!serverReachable) {
                        // Server is unreachable even though browser thinks we're online
                        console.log('Server unreachable despite online status');
                        // Don't change network status, but log for debugging
                    } else if (AppState.sync.offlineQueue.length > 0) {
                        // Server is reachable and we have queued actions - try to sync
                        console.log('Server reachable with pending queue - attempting sync');
                        await processOfflineQueueEnhanced();
                        await syncWithServer();
                    }
                }
            }, 30000); // 30 seconds
        }

        function stopConnectivityMonitoring() {
            if (connectivityCheckInterval) {
                clearInterval(connectivityCheckInterval);
                connectivityCheckInterval = null;
                console.log('Connectivity monitoring stopped');
            }
        }

        // ============================================
        // LEGACY COMPATIBILITY LAYER
        // ============================================
        // Maintain backward compatibility with existing code

        Object.defineProperty(window, 'currentStreak', {
            get() { return AppState.streak.current; },
            set(value) { AppState.streak.current = value; }
        });

        Object.defineProperty(window, 'lastCompletedDate', {
            get() { return AppState.streak.lastCompletedDate; },
            set(value) { AppState.streak.lastCompletedDate = value; }
        });

        // ============================================
        // CORE APPLICATION FUNCTIONS
        // ============================================

        function getTodaysTask() {
            const today = new Date();
            const dayOfMonth = today.getDate();
            return cleaningTasks[(dayOfMonth - 1) % cleaningTasks.length];
        }

        /**
         * Get legacy task for users without room configuration
         * Uses day-of-month rotation for backward compatibility
         */
        function getLegacyTask() {
            const today = new Date();
            const dayOfMonth = today.getDate();
            const taskDescription = cleaningTasks[(dayOfMonth - 1) % cleaningTasks.length];

            return {
                description: taskDescription,
                isLegacy: true
            };
        }

        /**
         * Fetch current task from rotation API or fallback to legacy
         * @returns {Promise<object>} Current task object
         */
        async function fetchCurrentTask() {
            try {
                // Check if user has configured rooms
                if (!AppState.user.hasConfiguredRooms) {
                    // Fallback to legacy system
                    return getLegacyTask();
                }

                // Fetch from rotation
                const response = await TaskAPI.getCurrentTask();

                if (response.task) {
                    // Cache in AppState
                    AppState.currentTask = {
                        id: response.task.id,
                        description: response.task.description,
                        taskType: response.task.task_type,
                        room: response.task.room,
                        pillarType: response.task.pillar_type,
                        keystoneType: response.task.keystone_type,
                        position: response.task.position,
                        totalTasks: response.task.total_tasks
                    };

                    return AppState.currentTask;
                }
            } catch (error) {
                console.error('Failed to fetch current task:', error);

                // Fallback to legacy
                return getLegacyTask();
            }
        }

        function getTodayString() {
            const today = new Date();
            return today.toDateString();
        }

        /**
         * Helper function to capitalize first letter
         */
        function capitalizeFirst(str) {
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        /**
         * Display current task with progress indicators and badges
         * Handles both rotation-based and legacy tasks
         */
        /**
         * Phase 7: Check migration status and show banner for users without rooms
         * Called after user authentication is verified
         */
        async function checkMigrationStatus() {
            if (!AppState.user.isAuthenticated) return;

            // Check if banner was previously dismissed
            const dismissed = localStorage.getItem('migration_banner_dismissed');
            if (dismissed === 'true') return;

            try {
                const roomsResponse = await RoomAPI.getUserRooms();

                if (roomsResponse.rooms.length === 0) {
                    // User has no rooms - show banner
                    document.getElementById('migrationBanner').style.display = 'block';
                    AppState.user.hasConfiguredRooms = false;
                } else {
                    AppState.user.hasConfiguredRooms = true;
                }
            } catch (error) {
                console.error('Failed to check migration status:', error);
            }
        }

        /**
         * Phase 7: Dismiss migration banner
         * Hides banner and stores dismissal in localStorage
         */
        function dismissMigrationBanner() {
            document.getElementById('migrationBanner').style.display = 'none';
            localStorage.setItem('migration_banner_dismissed', 'true');
        }

        function displayCurrentTask() {
            const task = AppState.currentTask;

            if (!task) return;

            // Update description
            document.getElementById('taskText').textContent = task.description;

            if (task.isLegacy) {
                // Legacy mode
                document.getElementById('taskProgress').style.display = 'none';
                document.getElementById('taskContext').style.display = 'none';
                document.getElementById('legacyPrompt').style.display = 'block';
            } else {
                // Rotation mode
                document.getElementById('taskProgress').style.display = 'block';
                document.getElementById('legacyPrompt').style.display = 'none';

                // Update progress
                const percentage = (task.position / task.totalTasks) * 100;
                document.querySelector('.progress-fill').style.width = `${percentage}%`;
                document.getElementById('currentPosition').textContent = task.position;
                document.getElementById('totalTasks').textContent = task.totalTasks;

                // Update context badge
                const badge = document.getElementById('taskBadge');
                if (task.taskType === 'pillar') {
                    badge.textContent = `${task.room.name} - ${capitalizeFirst(task.pillarType)}`;
                    badge.className = 'badge pillar';
                } else {
                    badge.textContent = 'Keystone Task';
                    badge.className = 'badge keystone';
                }
                document.getElementById('taskContext').style.display = 'block';
            }
        }

        async function updateDisplay() {
            const todayString = getTodayString();

            // Fetch and display current task
            const task = await fetchCurrentTask();
            AppState.currentTask = task;
            displayCurrentTask();

            // Update streak display
            if (AppState.streak.lastCompletedDate === todayString) {
                document.getElementById('streakText').textContent = `ðŸ”¥ Current streak: ${AppState.streak.current} days`;
                document.getElementById('doneButton').textContent = 'Completed!';
                document.getElementById('doneButton').classList.add('completed');
                document.getElementById('doneButton').disabled = true;
                document.getElementById('completedMessage').style.display = 'block';
            } else {
                document.getElementById('streakText').textContent = `ðŸ”¥ Current streak: ${AppState.streak.current} days`;
                document.getElementById('doneButton').textContent = 'Done!';
                document.getElementById('doneButton').classList.remove('completed');
                document.getElementById('doneButton').disabled = false;
                document.getElementById('completedMessage').style.display = 'none';
            }
        }

        async function completeTask() {
            const task = AppState.currentTask;
            const todayString = getTodayString();

            if (!task) {
                showNotification('No task to complete', 'error');
                return;
            }

            if (AppState.streak.lastCompletedDate === todayString) {
                return;
            }

            try {
                // Animation
                document.querySelector('.container').classList.add('completion-animation');
                setTimeout(() => {
                    document.querySelector('.container').classList.remove('completion-animation');
                }, 600);

                // Prepare completion data
                const completionData = {
                    taskName: task.description,
                    completionDate: new Date().toISOString().split('T')[0],
                    notes: '',
                    task_rotation_id: task.isLegacy ? null : task.id
                };

                // If authenticated, save to server
                if (AppState.user.isAuthenticated) {
                    try {
                        const response = await UserAPI.completeTask(completionData.taskName);

                        if (response.success) {
                            // Update streak from server response
                            AppState.streak.current = response.streak.current_streak;
                            AppState.streak.bestStreak = response.streak.longest_streak;
                            AppState.streak.lastCompletedDate = todayString;

                            // Update engagement tracking
                            AppState.engagement.totalCompletions++;
                            AppState.engagement.consecutiveDays = AppState.streak.current;

                            // If rotation-based, load next task
                            if (response.next_task) {
                                AppState.currentTask = {
                                    id: response.next_task.id,
                                    description: response.next_task.description,
                                    taskType: response.next_task.task_type,
                                    room: response.next_task.room,
                                    pillarType: response.next_task.pillar_type,
                                    keystoneType: response.next_task.keystone_type,
                                    position: response.next_task.position,
                                    totalTasks: response.next_task.total_tasks
                                };
                                displayCurrentTask();
                                showNotification(`Great job! Next: ${response.next_task.description}`, 'success', 5000);
                            } else {
                                // Legacy mode - will change tomorrow
                                showNotification('Task completed! See you tomorrow.', 'success', 4000);
                            }

                            // Save to localStorage
                            saveState();

                            // Update display
                            updateDisplay();
                        }
                    } catch (error) {
                        console.error('Error saving to server:', error);

                        // Fallback to local completion
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        const yesterdayString = yesterday.toDateString();

                        if (AppState.streak.lastCompletedDate === yesterdayString || AppState.streak.current === 0) {
                            AppState.streak.current++;
                        } else {
                            AppState.streak.current = 1;
                        }

                        AppState.streak.lastCompletedDate = todayString;

                        // Update engagement tracking
                        AppState.engagement.totalCompletions++;
                        AppState.engagement.consecutiveDays = AppState.streak.current;

                        if (AppState.streak.current > AppState.streak.bestStreak) {
                            AppState.streak.bestStreak = AppState.streak.current;
                        }

                        // Queue for offline sync
                        AppState.sync.offlineQueue.push({
                            action: 'COMPLETE_TASK',
                            payload: completionData,
                            timestamp: new Date().toISOString(),
                            retryCount: 0
                        });

                        // Update sync queue indicator
                        updateSyncQueueIndicator();

                        // Show notification about queued action
                        if (!AppState.network.isOnline) {
                            showNotification('Task saved locally. Will sync when online.', 'info', 4000);
                        } else {
                            showNotification('Sync failed. Task queued for retry.', 'warning', 4000);
                        }

                        saveState();
                        updateDisplay();
                    }
                } else {
                    // Anonymous mode - local storage only
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayString = yesterday.toDateString();

                    if (AppState.streak.lastCompletedDate === yesterdayString || AppState.streak.current === 0) {
                        AppState.streak.current++;
                    } else {
                        AppState.streak.current = 1;
                    }

                    AppState.streak.lastCompletedDate = todayString;

                    // Update engagement tracking
                    AppState.engagement.totalCompletions++;
                    AppState.engagement.consecutiveDays = AppState.streak.current;

                    if (AppState.streak.current > AppState.streak.bestStreak) {
                        AppState.streak.bestStreak = AppState.streak.current;
                    }

                    saveState();
                    updateDisplay();
                    showNotification('Task completed!', 'success', 3000);
                }
            } catch (error) {
                console.error('Error completing task:', error);
                showNotification('Failed to complete task. Please try again.', 'error', 4000);
            }
        }

        // ============================================
        // AUTHENTICATION LOGIC (Step 27)
        // ============================================

        /**
         * Show authentication modal
         * @param {string} mode - 'login' or 'register'
         */
        function showAuthModal(mode = 'login') {
            AppState.ui.authModalMode = mode;
            AppState.ui.authModalVisible = true;

            const overlay = document.getElementById('authOverlay');
            const loginForm = document.getElementById('loginForm');
            const registerForm = document.getElementById('registerForm');

            if (mode === 'login') {
                loginForm.style.display = 'block';
                registerForm.style.display = 'none';
            } else {
                loginForm.style.display = 'none';
                registerForm.style.display = 'block';
            }

            overlay.style.display = 'flex';

            // Clear any previous errors
            document.getElementById('loginError').classList.remove('show');
            document.getElementById('registerError').classList.remove('show');
        }

        /**
         * Hide authentication modal
         */
        function hideAuthModal() {
            AppState.ui.authModalVisible = false;
            document.getElementById('authOverlay').style.display = 'none';

            // Clear form fields
            document.getElementById('loginFormElement').reset();
            document.getElementById('registerFormElement').reset();
        }

        /**
         * Show error message in auth form
         * @param {string} formType - 'login' or 'register'
         * @param {string} message - Error message to display
         */
        function showAuthError(formType, message) {
            const errorElement = document.getElementById(`${formType}Error`);
            errorElement.textContent = message;
            errorElement.classList.add('show');
        }

        // ============================================
        // ONBOARDING LOGIC
        // ============================================

        /**
         * Onboarding state
         */
        const OnboardingState = {
            rooms: [],
            isConfiguring: false
        };

        /**
         * Room type icons mapping
         */
        const roomIcons = {
            living_room: 'ðŸ›‹ï¸',
            bedroom: 'ðŸ›ï¸',
            kitchen: 'ðŸ³',
            bathroom: 'ðŸš¿',
            office: 'ðŸ’¼',
            dining_room: 'ðŸ½ï¸',
            laundry: 'ðŸ§º',
            garage: 'ðŸš—'
        };

        /**
         * Format room type for display
         */
        function formatRoomType(roomType) {
            return roomType.split('_').map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        /**
         * Show onboarding modal
         */
        function showOnboardingModal() {
            const overlay = document.getElementById('onboardingOverlay');
            overlay.style.display = 'flex';

            // Load any existing rooms
            loadUserRooms();
        }

        /**
         * Hide onboarding modal
         */
        function hideOnboardingModal() {
            const overlay = document.getElementById('onboardingOverlay');
            overlay.style.display = 'none';

            // Reset form
            document.getElementById('roomForm').reset();
        }

        /**
         * Load user's configured rooms
         */
        async function loadUserRooms() {
            try {
                const response = await RoomAPI.getUserRooms();
                OnboardingState.rooms = response.rooms || [];
                renderRoomsList();

                // Enable finish button if rooms exist
                const finishBtn = document.getElementById('finishOnboarding');
                finishBtn.disabled = OnboardingState.rooms.length === 0;
            } catch (error) {
                console.error('Failed to load rooms:', error);
                // Show empty state
                OnboardingState.rooms = [];
                renderRoomsList();
            }
        }

        /**
         * Render rooms list
         */
        function renderRoomsList() {
            const container = document.getElementById('roomsContainer');

            if (OnboardingState.rooms.length === 0) {
                container.innerHTML = '<p class="empty-state">No rooms added yet. Add your first room below!</p>';
                return;
            }

            container.innerHTML = OnboardingState.rooms.map(room => `
                <div class="room-card" data-room-id="${room.id}">
                    <div class="room-header">
                        <span class="room-icon">${roomIcons[room.room_type] || 'ðŸ '}</span>
                        <span class="room-name">${room.custom_name}</span>
                        <span class="room-type-badge">${formatRoomType(room.room_type)}</span>
                    </div>
                    <div class="room-details">
                        <span class="glass-indicator">${room.has_glass ? 'ðŸªŸ Has glass' : 'No glass'}</span>
                    </div>
                    <div class="room-actions">
                        <button class="delete-room-btn" data-room-id="${room.id}">Delete</button>
                    </div>
                </div>
            `).join('');

            // Add delete event listeners
            container.querySelectorAll('.delete-room-btn').forEach(btn => {
                btn.addEventListener('click', handleDeleteRoom);
            });
        }

        /**
         * Handle room form submission
         */
        async function handleRoomFormSubmit(event) {
            event.preventDefault();

            const roomData = {
                roomType: document.getElementById('roomType').value,
                customName: document.getElementById('customRoomName').value.trim(),
                hasGlass: document.getElementById('hasGlass').checked
            };

            try {
                const response = await RoomAPI.createRoom(roomData);

                if (response.success && response.room) {
                    // Add to state
                    OnboardingState.rooms.push(response.room);

                    // Re-render list
                    renderRoomsList();

                    // Enable finish button
                    document.getElementById('finishOnboarding').disabled = false;

                    // Reset form
                    event.target.reset();

                    showNotification('Room added successfully!', 'success', 2000);
                }
            } catch (error) {
                console.error('Failed to add room:', error);
                showNotification(error.message || 'Failed to add room. Please try again.', 'error', 3000);
            }
        }

        /**
         * Handle room deletion
         */
        async function handleDeleteRoom(event) {
            const roomId = event.target.dataset.roomId;

            if (!confirm('Are you sure you want to delete this room?')) {
                return;
            }

            try {
                await RoomAPI.deleteRoom(roomId);

                // Remove from state
                OnboardingState.rooms = OnboardingState.rooms.filter(r => r.id !== roomId);

                // Re-render
                renderRoomsList();

                // Disable finish button if no rooms left
                if (OnboardingState.rooms.length === 0) {
                    document.getElementById('finishOnboarding').disabled = true;
                }

                showNotification('Room deleted successfully!', 'success', 2000);
            } catch (error) {
                console.error('Failed to delete room:', error);
                showNotification(error.message || 'Failed to delete room.', 'error', 3000);
            }
        }

        /**
         * Handle finish onboarding - generate rotation
         */
        async function handleFinishOnboarding() {
            if (OnboardingState.rooms.length === 0) {
                showNotification('Please add at least one room first.', 'warning', 3000);
                return;
            }

            try {
                showNotification('Generating your task rotation...', 'info', 2000);

                // Trigger rotation generation
                const rotation = await TaskAPI.regenerateRotation();

                if (rotation.success) {
                    // Close onboarding modal
                    hideOnboardingModal();

                    // Show success message
                    showNotification(`${rotation.rotation.total_tasks} tasks generated! Ready to start cleaning.`, 'success', 4000);

                    // Update app state
                    AppState.user.hasConfiguredRooms = true;
                    saveState();

                    // Reload the page to fetch the first task
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                }
            } catch (error) {
                console.error('Failed to generate tasks:', error);
                showNotification(error.message || 'Failed to generate tasks. Please try again.', 'error', 3000);
            }
        }

        /**
         * Handle skip onboarding
         */
        function handleSkipOnboarding() {
            if (confirm('You can configure your rooms anytime in Settings. Continue with default tasks?')) {
                hideOnboardingModal();
                AppState.user.hasConfiguredRooms = false;
                saveState();
                showNotification('You can set up rooms anytime!', 'info', 3000);
            }
        }

        // ============================================
        // SETTINGS MODAL FUNCTIONS
        // ============================================

        const SettingsState = {
            rooms: [],
            keystones: [],
            hasUnsavedChanges: false,
            isPendingCycleCompletion: false
        };

        /**
         * Open settings modal and load current configuration
         */
        async function openSettingsModal() {
            document.getElementById('settingsOverlay').style.display = 'flex';

            // Reset to rooms tab
            switchTab('rooms');

            // Load all settings data
            await loadSettingsData();
        }

        /**
         * Close settings modal
         */
        function closeSettingsModal() {
            if (SettingsState.hasUnsavedChanges) {
                if (!confirm('You have unsaved changes. Close without saving?')) {
                    return;
                }
            }

            document.getElementById('settingsOverlay').style.display = 'none';
            SettingsState.hasUnsavedChanges = false;
            hideAddRoomForm();
        }

        /**
         * Switch between tabs in settings modal
         */
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(`${tabName}Tab`).classList.add('active');

            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

            // Load data for specific tabs
            if (tabName === 'preview') {
                loadTaskPreview();
            } else if (tabName === 'account') {
                loadAccountInfo();
            }
        }

        /**
         * Load all settings data from API
         */
        async function loadSettingsData() {
            try {
                // Load rooms
                const roomsResponse = await RoomAPI.getUserRooms();
                SettingsState.rooms = roomsResponse.rooms || [];
                renderSettingsRoomsList();

                // Load keystones
                const keystonesResponse = await KeystoneAPI.getUserKeystones();
                SettingsState.keystones = keystonesResponse.keystone_tasks || [];
                renderKeystonesList();

            } catch (error) {
                console.error('Failed to load settings data:', error);
                showNotification('Failed to load settings', 'error', 3000);
            }
        }

        /**
         * Render rooms list in settings
         */
        function renderSettingsRoomsList() {
            const container = document.getElementById('settingsRoomsList');

            if (SettingsState.rooms.length === 0) {
                container.innerHTML = '<p class="empty-state">No rooms configured yet. Add your first room below!</p>';
                return;
            }

            container.innerHTML = SettingsState.rooms.map((room, index) => `
                <div class="settings-room-card" data-room-id="${room.id}">
                    <div class="settings-room-header">
                        <div class="room-reorder-controls">
                            <button class="reorder-btn" onclick="moveRoomUp('${room.id}')" ${index === 0 ? 'disabled' : ''}>â–²</button>
                            <button class="reorder-btn" onclick="moveRoomDown('${room.id}')" ${index === SettingsState.rooms.length - 1 ? 'disabled' : ''}>â–¼</button>
                        </div>
                        <div class="room-icon">${getRoomIcon(room.room_type)}</div>
                        <div class="room-name">${room.custom_name}</div>
                        <div class="room-type-badge">${formatRoomType(room.room_type)}</div>
                    </div>
                    <div class="room-details">
                        <span class="glass-indicator">${room.has_glass ? 'ðŸªŸ Has glass' : 'No glass'}</span>
                    </div>
                    <div class="room-actions">
                        <button class="edit-room-btn" onclick="editRoom('${room.id}')">Edit</button>
                        <button class="delete-room-btn" onclick="deleteRoom('${room.id}')">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        /**
         * Render keystones list in settings
         */
        function renderKeystonesList() {
            const container = document.getElementById('keystonesList');

            if (SettingsState.keystones.length === 0) {
                container.innerHTML = '<p class="empty-state">No keystone tasks available.</p>';
                return;
            }

            container.innerHTML = SettingsState.keystones.map(keystone => `
                <div class="keystone-item" data-keystone-id="${keystone.id}">
                    <div class="keystone-toggle">
                        <label class="switch">
                            <input type="checkbox"
                                   class="keystone-active-toggle"
                                   onchange="toggleKeystone('${keystone.id}', this.checked)"
                                   ${keystone.is_active ? 'checked' : ''}>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="keystone-info">
                        <div class="keystone-default-name">${getKeystoneDefaultName(keystone.task_type)}</div>
                        <input type="text"
                               class="keystone-custom-name"
                               placeholder="Custom name (optional)"
                               value="${keystone.custom_name || ''}"
                               onchange="updateKeystoneCustomName('${keystone.id}', this.value)">
                    </div>
                </div>
            `).join('');
        }

        /**
         * Load task preview
         */
        async function loadTaskPreview() {
            try {
                const response = await TaskAPI.previewTasks(20);
                renderTaskPreview(response.tasks || [], response.current_position || 0, response.total_tasks || 0);
            } catch (error) {
                console.error('Failed to load task preview:', error);
                document.getElementById('taskPreviewList').innerHTML = '<p class="empty-state">Failed to load task preview.</p>';
            }
        }

        /**
         * Render task preview
         */
        function renderTaskPreview(tasks, currentPosition, totalTasks) {
            const container = document.getElementById('taskPreviewList');

            if (tasks.length === 0) {
                container.innerHTML = '<p class="empty-state">No tasks in rotation yet. Configure rooms to generate tasks.</p>';
                return;
            }

            container.innerHTML = tasks.map(task => `
                <div class="preview-task-item ${task.position === currentPosition ? 'current' : ''}" data-position="${task.position}">
                    <div class="task-number">${task.position}</div>
                    <div class="task-description">${task.description}</div>
                    <div class="task-meta">
                        ${task.task_type === 'pillar'
                            ? `<span class="badge pillar">${task.room ? task.room.name : 'Room'} - ${task.pillar_type}</span>`
                            : `<span class="badge keystone">Keystone</span>`
                        }
                    </div>
                </div>
            `).join('');

            document.getElementById('currentPositionPreview').textContent = currentPosition;
            document.getElementById('totalTasksPreview').textContent = totalTasks;
        }

        /**
         * Load account info
         */
        function loadAccountInfo() {
            if (AppState.user.isAuthenticated && AppState.user.profile) {
                document.getElementById('accountEmail').textContent = AppState.user.profile.email || '-';
                document.getElementById('accountCreated').textContent = AppState.user.profile.createdAt
                    ? new Date(AppState.user.profile.createdAt).toLocaleDateString()
                    : '-';
                document.getElementById('accountCompletions').textContent = AppState.engagement.totalCompletions || 0;
            }
        }

        /**
         * Show add room form in settings
         */
        function showAddRoomForm() {
            document.getElementById('addRoomInSettings').style.display = 'block';
            document.getElementById('addRoomSettingsBtn').style.display = 'none';
        }

        /**
         * Hide add room form in settings
         */
        function hideAddRoomForm() {
            document.getElementById('addRoomInSettings').style.display = 'none';
            document.getElementById('addRoomSettingsBtn').style.display = 'block';
            document.getElementById('roomFormSettings').reset();
        }

        /**
         * Handle add room form submission in settings
         */
        async function handleAddRoomInSettings(event) {
            event.preventDefault();

            const roomType = document.getElementById('roomTypeSettings').value;
            const customName = document.getElementById('customRoomNameSettings').value.trim();
            const hasGlass = document.getElementById('hasGlassSettings').checked;

            try {
                const response = await RoomAPI.createRoom({ roomType, customName, hasGlass });

                if (response.success && response.room) {
                    SettingsState.rooms.push(response.room);
                    renderSettingsRoomsList();
                    hideAddRoomForm();
                    SettingsState.hasUnsavedChanges = false; // Room already saved via API
                    showNotification('Room added successfully!', 'success', 3000);
                }
            } catch (error) {
                console.error('Failed to add room:', error);
                showNotification('Failed to add room. Please try again.', 'error', 3000);
            }
        }

        /**
         * Move room up in order
         */
        function moveRoomUp(roomId) {
            const index = SettingsState.rooms.findIndex(r => r.id === roomId);
            if (index > 0) {
                [SettingsState.rooms[index], SettingsState.rooms[index - 1]] =
                [SettingsState.rooms[index - 1], SettingsState.rooms[index]];

                SettingsState.rooms.forEach((room, i) => {
                    room.sort_order = i + 1;
                });

                renderSettingsRoomsList();
                SettingsState.hasUnsavedChanges = true;
            }
        }

        /**
         * Move room down in order
         */
        function moveRoomDown(roomId) {
            const index = SettingsState.rooms.findIndex(r => r.id === roomId);
            if (index < SettingsState.rooms.length - 1) {
                [SettingsState.rooms[index], SettingsState.rooms[index + 1]] =
                [SettingsState.rooms[index + 1], SettingsState.rooms[index]];

                SettingsState.rooms.forEach((room, i) => {
                    room.sort_order = i + 1;
                });

                renderSettingsRoomsList();
                SettingsState.hasUnsavedChanges = true;
            }
        }

        /**
         * Delete a room
         */
        async function deleteRoom(roomId) {
            if (!confirm('Delete this room? This will take effect after completing the current rotation.')) {
                return;
            }

            try {
                const response = await RoomAPI.deleteRoom(roomId);

                if (response.success) {
                    SettingsState.rooms = SettingsState.rooms.filter(r => r.id !== roomId);
                    renderSettingsRoomsList();
                    SettingsState.isPendingCycleCompletion = true;
                    document.getElementById('pendingChangesNotice').style.display = 'block';
                    showNotification('Room will be removed after current cycle', 'info', 3000);
                }
            } catch (error) {
                console.error('Failed to delete room:', error);
                showNotification('Failed to delete room', 'error', 3000);
            }
        }

        /**
         * Edit a room (simplified - just shows form with values)
         */
        function editRoom(roomId) {
            // For MVP, we'll use a simple prompt. Full implementation would use a modal
            showNotification('Edit functionality: Use delete and re-add for now', 'info', 3000);
        }

        /**
         * Toggle keystone active state
         */
        function toggleKeystone(keystoneId, isActive) {
            const keystone = SettingsState.keystones.find(k => k.id === keystoneId);
            if (keystone) {
                keystone.is_active = isActive;
                SettingsState.hasUnsavedChanges = true;
            }
        }

        /**
         * Update keystone custom name
         */
        function updateKeystoneCustomName(keystoneId, customName) {
            const keystone = SettingsState.keystones.find(k => k.id === keystoneId);
            if (keystone) {
                keystone.custom_name = customName || null;
                SettingsState.hasUnsavedChanges = true;
            }
        }

        /**
         * Save all settings changes
         */
        async function handleSaveSettings() {
            if (!SettingsState.hasUnsavedChanges) {
                closeSettingsModal();
                return;
            }

            try {
                // Save room order if changed
                if (SettingsState.hasUnsavedChanges) {
                    const roomIds = SettingsState.rooms.map(r => r.id);
                    await RoomAPI.reorderRooms(roomIds);
                }

                // Save keystone changes
                for (const keystone of SettingsState.keystones) {
                    if (keystone.is_active !== undefined || keystone.custom_name !== undefined) {
                        await KeystoneAPI.updateKeystone(keystone.id, {
                            isActive: keystone.is_active,
                            customName: keystone.custom_name
                        });
                    }
                }

                SettingsState.hasUnsavedChanges = false;
                SettingsState.isPendingCycleCompletion = true;
                document.getElementById('pendingChangesNotice').style.display = 'block';

                showNotification('Settings saved! Changes will apply after completing current cycle.', 'success', 3000);
            } catch (error) {
                console.error('Failed to save settings:', error);
                showNotification('Failed to save settings', 'error', 3000);
            }
        }

        /**
         * Get room icon emoji
         */
        function getRoomIcon(roomType) {
            const icons = {
                living_room: 'ðŸ›‹ï¸',
                bedroom: 'ðŸ›ï¸',
                kitchen: 'ðŸ³',
                bathroom: 'ðŸš¿',
                office: 'ðŸ’¼',
                dining_room: 'ðŸ½ï¸',
                laundry: 'ðŸ§º',
                garage: 'ðŸš—'
            };
            return icons[roomType] || 'ðŸ ';
        }

        /**
         * Format room type for display
         */
        function formatRoomType(roomType) {
            return roomType.split('_').map(word =>
                word.charAt(0).toUpperCase() + word.slice(1)
            ).join(' ');
        }

        /**
         * Get keystone default name
         */
        function getKeystoneDefaultName(taskType) {
            const names = {
                master_toilet: 'Scrub and disinfect master toilet',
                guest_toilet: 'Scrub and disinfect guest/hall toilet',
                kitchen_sink: 'Scrub kitchen sink and faucet',
                master_bath_sink: 'Clean master bathroom sink',
                guest_bath_sink: 'Clean guest bathroom sink',
                stovetop: 'Wipe down stovetop and burners',
                shower_tub: 'Scrub shower/tub',
                microwave: 'Clean microwave interior'
            };
            return names[taskType] || taskType;
        }

        /**
         * Handle user registration
         * @param {Event} event - Form submit event
         */
        async function handleRegister(event) {
            event.preventDefault();

            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;

            // Clear previous errors
            document.getElementById('registerError').classList.remove('show');

            // Client-side validation
            if (!email || !password || !confirmPassword) {
                showAuthError('register', 'All fields are required');
                return;
            }

            if (password !== confirmPassword) {
                showAuthError('register', 'Passwords do not match');
                return;
            }

            if (password.length < 8) {
                showAuthError('register', 'Password must be at least 8 characters');
                return;
            }

            // Show loading state
            const submitButton = document.getElementById('registerSubmitButton');
            submitButton.disabled = true;
            submitButton.classList.add('loading');

            try {
                // Call register API
                const response = await AuthAPI.register(email, password, confirmPassword);

                // Update state with user data
                AppState.user.isAuthenticated = true;
                AppState.user.profile = {
                    id: response.user.id,
                    email: response.user.email,
                    createdAt: response.user.createdAt,
                    preferences: response.user.preferences || {}
                };

                // Migrate any anonymous data
                await migrateAnonymousData();

                // Sync with server to get latest data
                await syncWithServer();

                // Start background sync for authenticated user
                startBackgroundSync();

                // Start connectivity monitoring
                startConnectivityMonitoring();

                // Save state
                saveState();

                // Update UI
                updateAuthUI();
                updateConnectionStatus();
                updateSyncQueueIndicator();

                // Hide modal
                hideAuthModal();

                // Show success notification
                showNotification('Account created successfully!', 'success', 3000);
                console.log('Registration successful!');

                // Show onboarding modal to configure rooms
                setTimeout(() => {
                    showOnboardingModal();
                }, 500);
            } catch (error) {
                console.error('Registration error:', error);
                showAuthError('register', error.message || 'Registration failed. Please try again.');
            } finally {
                // Reset button state
                submitButton.disabled = false;
                submitButton.classList.remove('loading');
            }
        }

        /**
         * Handle user login
         * @param {Event} event - Form submit event
         */
        async function handleLogin(event) {
            event.preventDefault();

            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            // Clear previous errors
            document.getElementById('loginError').classList.remove('show');

            // Client-side validation
            if (!email || !password) {
                showAuthError('login', 'Email and password are required');
                return;
            }

            // Show loading state
            const submitButton = document.getElementById('loginSubmitButton');
            submitButton.disabled = true;
            submitButton.classList.add('loading');

            try {
                // Call login API
                const response = await AuthAPI.login(email, password);

                // Update state with user data
                AppState.user.isAuthenticated = true;
                AppState.user.profile = {
                    id: response.user.id,
                    email: response.user.email,
                    createdAt: response.user.createdAt,
                    preferences: response.user.preferences || {}
                };

                // Migrate any anonymous data
                await migrateAnonymousData();

                // Sync with server to get latest data
                await syncWithServer();

                // Start background sync for authenticated user
                startBackgroundSync();

                // Start connectivity monitoring
                startConnectivityMonitoring();

                // Save state
                saveState();

                // Update UI
                updateAuthUI();
                updateConnectionStatus();
                updateSyncQueueIndicator();

                // Phase 7: Check migration status and show banner if needed
                await checkMigrationStatus();

                // Hide modal
                hideAuthModal();

                // Show success notification
                showNotification('Welcome back!', 'success', 3000);
                console.log('Login successful!');
            } catch (error) {
                console.error('Login error:', error);

                // Provide helpful error message
                let errorMessage = error.message || 'Login failed. Please check your credentials.';

                // If it's an authentication error, add helpful reminder
                if (errorMessage.includes('Invalid') || errorMessage.includes('password') || errorMessage.includes('credentials')) {
                    errorMessage = 'Invalid email or password. Don\'t have an account? Click "Create one" below.';
                }

                showAuthError('login', errorMessage);
            } finally {
                // Reset button state
                submitButton.disabled = false;
                submitButton.classList.remove('loading');
            }
        }

        /**
         * Handle user logout
         */
        async function handleLogout() {
            try {
                // Call logout API
                await AuthAPI.logout();
            } catch (error) {
                console.error('Logout error:', error);
                // Continue with local logout even if API call fails
            }

            // Stop background sync and connectivity monitoring
            stopBackgroundSync();
            stopConnectivityMonitoring();

            // Clear authenticated state
            AppState.user.isAuthenticated = false;
            AppState.user.profile = null;
            AppState.sync.status = 'idle';
            AppState.sync.lastSyncTime = null;
            AppState.sync.offlineQueue = [];

            // Clear authenticated data from localStorage
            clearState();

            // Reset to anonymous state
            AppState.streak = {
                current: 0,
                lastCompletedDate: null,
                bestStreak: 0,
                history: []
            };
            AppState.engagement = {
                totalCompletions: 0,
                consecutiveDays: 0,
                firstVisit: null,
                lastVisit: null,
                visitCount: 0,
                hasSeenAuthPrompt: false,
                dismissedAuthPromptCount: 0
            };

            // Update UI
            updateAuthUI();
            updateConnectionStatus();
            updateSyncQueueIndicator();
            updateDisplay();

            // Show notification
            showNotification('Logged out successfully', 'info', 3000);

            console.log('Logged out successfully');
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        // Load state on page load
        loadState();

        // Update UI to match authentication state
        updateAuthUI();

        // Initialize connection status display
        updateConnectionStatus();

        // Initialize sync queue indicator
        updateSyncQueueIndicator();

        // Start background sync if user is authenticated
        if (AppState.user.isAuthenticated) {
            startBackgroundSync();
            startConnectivityMonitoring();
            // Phase 7: Check migration status on app load
            checkMigrationStatus();
        }

        // Network status monitoring with enhanced offline handling
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);

        // Event listeners - Core functionality
        document.getElementById('doneButton').addEventListener('click', completeTask);

        // Event listeners - Authentication
        document.getElementById('loginButton').addEventListener('click', () => showAuthModal('login'));
        document.getElementById('logoutButton').addEventListener('click', handleLogout);

        // Form submissions
        document.getElementById('loginFormElement').addEventListener('submit', handleLogin);
        document.getElementById('registerFormElement').addEventListener('submit', handleRegister);

        // Modal controls
        document.getElementById('closeLoginModal').addEventListener('click', hideAuthModal);
        document.getElementById('closeRegisterModal').addEventListener('click', hideAuthModal);

        // Switch between login and register
        document.getElementById('showRegisterLink').addEventListener('click', (e) => {
            e.preventDefault();
            showAuthModal('register');
        });
        document.getElementById('showLoginLink').addEventListener('click', (e) => {
            e.preventDefault();
            showAuthModal('login');
        });

        // Close modal when clicking overlay
        document.getElementById('authOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'authOverlay') {
                hideAuthModal();
            }
        });

        // Event listeners - Onboarding
        document.getElementById('roomForm').addEventListener('submit', handleRoomFormSubmit);
        document.getElementById('finishOnboarding').addEventListener('click', handleFinishOnboarding);
        document.getElementById('skipOnboarding').addEventListener('click', handleSkipOnboarding);

        // Close onboarding when clicking overlay
        document.getElementById('onboardingOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'onboardingOverlay') {
                // Don't allow closing by clicking overlay during onboarding
                // User must complete or skip
            }
        });

        // Event listeners - Settings Modal
        document.getElementById('settingsButton').addEventListener('click', openSettingsModal);
        document.getElementById('closeSettingsModal').addEventListener('click', closeSettingsModal);
        document.getElementById('cancelSettingsBtn').addEventListener('click', closeSettingsModal);
        document.getElementById('saveSettingsBtn').addEventListener('click', handleSaveSettings);

        // Settings - Room Management
        document.getElementById('addRoomSettingsBtn').addEventListener('click', showAddRoomForm);
        document.getElementById('cancelAddRoomSettings').addEventListener('click', hideAddRoomForm);
        document.getElementById('roomFormSettings').addEventListener('submit', handleAddRoomInSettings);

        // Settings - Tab Switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tabName = e.target.dataset.tab;
                switchTab(tabName);
            });
        });

        // Close settings when clicking overlay
        document.getElementById('settingsOverlay').addEventListener('click', (e) => {
            if (e.target.id === 'settingsOverlay') {
                closeSettingsModal();
            }
        });

        // Initial display update
        updateDisplay();
    </script>
</body>
</html>